<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linux进程管理子系统详解</title>
    
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Framer Motion -->
    <script src="https://unpkg.com/framer-motion@10.12.4/dist/framer-motion.umd.min.js"></script>
    
    <!-- Material Icons -->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;900&family=Noto+Sans+SC:wght@400;500;700;900&display=swap" rel="stylesheet">
    
    <!-- Prism.js for code highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
    
    <style>
        :root {
            --primary: #445566;
            --secondary: #E65D2E;
            --accent: #446B7C;
            --light: #F5E6D3;
            --light-accent: #E8F4F2;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Inter', 'Noto Sans SC', sans-serif;
            background-color: #f8f9fb;
        }
        
        .bento-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 24px;
        }
        
        .gradient-bg {
            background: linear-gradient(135deg, rgba(68, 85, 102, 0.9) 0%, rgba(68, 107, 124, 0.8) 100%);
        }
        
        .highlight-gradient {
            background: linear-gradient(180deg, var(--secondary) 0%, rgba(230, 93, 46, 0.7) 100%);
        }
        
        .accent-gradient {
            background: linear-gradient(180deg, var(--accent) 0%, rgba(68, 107, 124, 0.7) 100%);
        }
        
        .light-gradient {
            background: linear-gradient(135deg, var(--light) 0%, rgba(245, 230, 211, 0.7) 100%);
        }
        
        .mega-text {
            font-size: clamp(3rem, 10vw, 8rem);
            font-weight: 900;
            line-height: 0.9;
        }
        
        .section {
            opacity: 0;
            transform: translateY(50px);
            transition: opacity 1s ease, transform 1s ease;
        }
        
        .section.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        .code-block {
            border-radius: 12px;
            margin: 24px 0;
        }
        
        .diagram {
            max-width: 100%;
            height: auto;
            margin: 32px 0;
        }
        
        .thin-line {
            height: 1px;
            background: linear-gradient(90deg, transparent, var(--primary), transparent);
        }
        
        /* 修复Prism.js与TailwindCSS的冲突 */
        pre[class*="language-"] {
            background: #2d2d2d !important;
            margin: 0 !important;
            padding: 16px !important;
            border-radius: 12px !important;
        }
        
        /* Apple-style scroll animations */
        .parallax-element {
            will-change: transform;
        }
    </style>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#445566',
                        secondary: '#E65D2E',
                        accent: '#446B7C',
                        light: '#F5E6D3',
                        lightAccent: '#E8F4F2',
                    }
                }
            }
        }
    </script>
</head>
<body class="overflow-x-hidden">
    <!-- Hero Section -->
    <header class="min-h-screen flex flex-col justify-center items-center p-8 gradient-bg text-white relative">
        <div class="absolute inset-0 z-0 opacity-30">
            <svg width="100%" height="100%" viewBox="0 0 100 100" preserveAspectRatio="none">
                <defs>
                    <pattern id="grid" width="8" height="8" patternUnits="userSpaceOnUse">
                        <path d="M 8 0 L 0 0 0 8" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.5"/>
                    </pattern>
                </defs>
                <rect width="100%" height="100%" fill="url(#grid)"/>
            </svg>
        </div>
        <div class="relative z-10 max-w-7xl mx-auto text-center">
            <h1 class="mega-text mb-6">LINUX<br/><span class="text-secondary">进程管理</span><br/>子系统</h1>
            <p class="text-xl md:text-2xl mb-8 font-light tracking-wide max-w-3xl mx-auto">
                从内核源码角度深入解析 Linux 的进程创建、调度、通信与同步机制
                <span class="block mt-2 text-sm opacity-70">PROCESS MANAGEMENT SUBSYSTEM</span>
            </p>
            <div class="flex justify-center gap-4 mt-12">
                <a href="#overview" class="px-8 py-3 rounded-full bg-white bg-opacity-10 hover:bg-opacity-20 transition-all border border-white border-opacity-20 backdrop-blur-sm flex items-center gap-2">
                    <span class="material-icons">explore</span>
                    开始探索
                </a>
                <a href="#code" class="px-8 py-3 rounded-full highlight-gradient hover:opacity-90 transition-all flex items-center gap-2">
                    <span class="material-icons">code</span>
                    查看源码
                </a>
            </div>
        </div>
        <div class="absolute bottom-10 left-1/2 transform -translate-x-1/2 animate-bounce">
            <span class="material-icons text-4xl">keyboard_arrow_down</span>
        </div>
    </header>

    <main class="container mx-auto px-4 py-16">
        <!-- Overview Section -->
        <section id="overview" class="section mb-32">
            <div class="bento-grid">
                <div class="col-span-12 md:col-span-5 lg:col-span-4 flex flex-col justify-center">
                    <h2 class="text-6xl md:text-7xl font-bold text-primary mb-6">
                        概述
                        <span class="block text-base font-normal text-secondary mt-2">OVERVIEW</span>
                    </h2>
                    <p class="text-lg text-gray-700 mb-6">
                        进程管理子系统是内核中的一个核心组件，负责进程的创建、调度、通信和终止等关键功能。通过深入分析内核源码，我们可以了解其设计理念、实现机制以及核心数据结构。
                    </p>
                    <div class="thin-line my-8"></div>
                    <div class="flex items-center gap-4">
                        <div class="w-12 h-12 rounded-full flex items-center justify-center gradient-bg">
                            <span class="material-icons text-white">memory</span>
                        </div>
                        <div>
                            <h4 class="font-bold">多任务处理</h4>
                            <p class="text-sm text-gray-500">内核级进程管理</p>
                        </div>
                    </div>
                </div>
                <div class="col-span-12 md:col-span-7 lg:col-span-8 light-gradient rounded-3xl p-8 flex flex-col justify-center">
                    <div class="relative h-[400px] overflow-hidden">
                        <div class="absolute inset-0" id="architecture-diagram">
                            <!-- 架构图 SVG 将通过 JS 生成 -->
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Process Representation Section -->
        <section id="representation" class="section mb-32">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    进程的表示与组织
                    <span class="block text-base font-normal text-secondary mt-2">PROCESS REPRESENTATION</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="bento-grid">
                <div class="col-span-12 md:col-span-6 lg:col-span-7 rounded-3xl bg-white shadow-lg p-8">
                    <h3 class="text-2xl font-bold mb-4">进程描述符 <span class="text-secondary">task_struct</span></h3>
                    <p class="mb-6">在Linux内核中，进程由<code>task_struct</code>结构体表示，定义在<code>include/linux/sched.h</code>文件中。这是Linux内核中最为重要的数据结构之一，包含了与进程相关的所有信息。</p>
                    
                    <pre class="code-block"><code class="language-c">struct task_struct {
    volatile long state;              /* -1不可运行, 0可运行, >0已停止 */
    void *stack;                /* 进程的内核栈 */
    atomic_t usage;                   /* 使用计数 */
    unsigned int flags;               /* 进程标志 */
    unsigned int ptrace;              /* 进程跟踪标志 */
    int prio, static_prio, normal_prio; /* 优先级 */
    struct list_head tasks;           /* 进程链表 */
    struct mm_struct *mm, *active_mm; /* 内存管理信息 */
    pid_t pid;                        /* 进程ID */
    pid_t tgid;                       /* 线程组ID */
    struct task_struct *parent;       /* 父进程 */
    struct list_head children;        /* 子进程链表 */
    struct list_head sibling;         /* 兄弟进程链表 */
    struct files_struct *files;       /* 打开的文件 */
    /* ... 更多字段 ... */
};</code></pre>
                </div>
                
                <div class="col-span-12 md:col-span-6 lg:col-span-5 flex flex-col gap-6">
                    <div class="rounded-3xl accent-gradient p-8 text-white h-1/2">
                        <h3 class="text-2xl font-bold mb-4">进程标识符 <span class="text-light">PID</span></h3>
                        <p class="mb-4">每个进程都有一个唯一的进程标识符（PID），在<code>task_struct</code>中由<code>pid</code>字段表示。</p>
                        <pre class="code-block"><code class="language-c">struct pid {
    atomic_t count;              /* 引用计数 */
    unsigned int level;          /* PID命名空间的级别 */
    struct hlist_head tasks[PIDTYPE_MAX]; /* 进程散列表 */
    struct rcu_head rcu;
    struct upid numbers[1];      /* PID在命名空间中的表示 */
};</code></pre>
                    </div>
                    
                    <div class="rounded-3xl bg-white shadow-lg p-8 h-1/2">
                        <h3 class="text-2xl font-bold mb-4">进程层次结构</h3>
                        <p class="mb-4">Linux进程以树状结构组织，每个进程（除init进程外）都有一个父进程。这种层次结构通过<code>task_struct</code>中的<code>parent</code>、<code>children</code>和<code>sibling</code>等字段维护。</p>
                        <div class="flex items-center gap-2 text-secondary">
                            <span class="material-icons">account_tree</span>
                            <span class="font-bold">进程树结构</span>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Process Creation Section -->
        <section id="creation" class="section mb-32">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    进程的创建与终止
                    <span class="block text-base font-normal text-secondary mt-2">PROCESS LIFECYCLE</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="bento-grid">
                <div class="col-span-12 md:col-span-6 rounded-3xl bg-white shadow-lg p-8">
                    <div class="flex items-center gap-4 mb-6">
                        <div class="w-16 h-16 rounded-full highlight-gradient flex items-center justify-center">
                            <span class="material-icons text-white text-3xl">add_circle_outline</span>
                        </div>
                        <h3 class="text-3xl font-bold">进程创建</h3>
                    </div>
                    
                    <p class="mb-4">Linux系统中，进程创建主要通过以下系统调用实现：</p>
                    
                    <h4 class="text-xl font-bold mb-2">fork系统调用</h4>
                    <p class="mb-4"><code>fork</code>是创建新进程的主要系统调用，在内核中由<code>sys_fork</code>函数实现，这个函数最终调用<code>do_fork</code>（在新版内核中重命名为<code>_do_fork</code>或<code>kernel_clone</code>）：</p>
                    
                    <pre class="code-block"><code class="language-c">// 在较新版本的内核中，对应函数名可能为_do_fork或kernel_clone
long do_fork(unsigned long clone_flags,
             unsigned long stack_start,
             unsigned long stack_size,
             int __user *parent_tidptr,
             int __user *child_tidptr,
             unsigned long tls)
{
    struct task_struct *p;
    int trace = 0;
    long nr;
    
    // 复制进程描述符，这是创建新进程最关键的一步
    p = copy_process(clone_flags, stack_start, stack_size,
                     parent_tidptr, child_tidptr, tls);
    
    if (!IS_ERR(p)) {
        // 为新进程分配PID
        nr = task_pid_vnr(p);
        
        // 如果复制成功，则启动新进程
        trace = ptrace_event_enabled(current, PTRACE_EVENT_FORK);
        if (!trace)
            wake_up_new_task(p);
        
        // 返回新创建进程的PID
    } else {
        nr = PTR_ERR(p);
    }
    
    return nr;
}</code></pre>
                    
                    <h4 class="text-xl font-bold mb-2 mt-6">exec系统调用</h4>
                    <p class="mb-4"><code>exec</code>系列系统调用用于在当前进程中载入并执行新的程序。它不会创建新进程，而是替换当前进程的内容。主要实现在<code>fs/exec.c</code>中。</p>
                </div>
                
                <div class="col-span-12 md:col-span-6 rounded-3xl gradient-bg p-8 text-white">
                    <div class="flex items-center gap-4 mb-6">
                        <div class="w-16 h-16 rounded-full bg-white bg-opacity-20 flex items-center justify-center">
                            <span class="material-icons text-white text-3xl">remove_circle_outline</span>
                        </div>
                        <h3 class="text-3xl font-bold">进程终止</h3>
                    </div>
                    
                    <p class="mb-4">进程终止通过<code>exit</code>系统调用实现，内核中的<code>sys_exit_group</code>（或<code>sys_exit</code>）函数处理此系统调用。进程终止流程主要由<code>do_exit</code>和<code>do_task_dead</code>函数实现：</p>
                    
                    <pre class="code-block"><code class="language-c">void do_exit(long code)
{
    struct task_struct *tsk = current;
    
    // 设置进程退出码
    tsk->exit_code = code;
    
    // 释放所有资源
    exit_signals(tsk);
    exit_mm(tsk);
    exit_files(tsk);
    exit_fs(tsk);
    
    // 通知父进程
    exit_notify(tsk, group_dead);
    
    // 调度器相关的清理工作
    schedule();
    BUG();  // 该进程不应再返回
}</code></pre>

                    <div class="mt-6">
                        <h4 class="text-xl font-bold mb-2">当进程终止时，内核会执行以下操作：</h4>
                        <ul class="list-disc list-inside space-y-2">
                            <li>将进程标记为退出状态</li>
                            <li>释放进程使用的各种资源，如内存、打开的文件等</li>
                            <li>向父进程发送SIGCHLD信号，通知子进程已终止</li>
                            <li>如果父进程已经调用了wait，则唤醒父进程</li>
                            <li>如果父进程还未调用wait，则将终止进程变为僵尸状态</li>
                            <li>如果父进程已经终止，则将终止进程的父进程设置为init进程</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- Process Scheduling Section -->
        <section id="scheduling" class="section mb-32">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    进程调度
                    <span class="block text-base font-normal text-secondary mt-2">PROCESS SCHEDULING</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="bento-grid">
                <div class="col-span-12 md:col-span-4 lg:col-span-3 rounded-3xl bg-white shadow-lg p-8">
                    <h3 class="text-2xl font-bold mb-4">调度器类层次结构</h3>
                    <p class="mb-4">Linux内核支持多种调度策略，这些策略通过调度器类(sched_class)来实现。调度器类定义了进程如何被调度的基本方法，系统中的调度器类按优先级排列：</p>
                    
                    <ol class="list-decimal list-inside space-y-2 mb-6">
                        <li class="font-bold">stop_sched_class <span class="text-xs block text-gray-500">优先级最高，用于停止其他进程</span></li>
                        <li class="font-bold">dl_sched_class <span class="text-xs block text-gray-500">截止时间调度类</span></li>
                        <li class="font-bold">rt_sched_class <span class="text-xs block text-gray-500">实时调度类</span></li>
                        <li class="font-bold">fair_sched_class <span class="text-xs block text-gray-500">完全公平调度类</span></li>
                        <li class="font-bold">idle_sched_class <span class="text-xs block text-gray-500">空闲调度类</span></li>
                    </ol>
                    
                    <div class="text-center">
                        <div class="inline-block p-4 rounded-full highlight-gradient text-white">
                            <span class="material-icons text-4xl">priority_high</span>
                        </div>
                        <p class="mt-2 text-sm">调度器类按<br/>优先级排列</p>
                    </div>
                </div>
                
                <div class="col-span-12 md:col-span-8 lg:col-span-9 rounded-3xl accent-gradient p-8 text-white">
                    <h3 class="text-3xl font-bold mb-6">完全公平调度器 (CFS)</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <p class="mb-4">CFS是Linux中最重要的调度器，处理普通非实时进程，实现在<code>kernel/sched/fair.c</code>中。CFS的核心思想是：为了实现进程调度的公平性，每个进程应该得到与其权重成比例的处理器时间。</p>
                            
                            <h4 class="text-xl font-bold mb-2">虚拟运行时间</h4>
                            <p class="mb-4">CFS使用一个关键概念：虚拟运行时间（vruntime）。vruntime表示一个进程的实际运行时间根据其权重（优先级）进行归一化后的值，计算公式为：</p>
                            <div class="bg-white bg-opacity-20 p-4 rounded-xl text-center mb-4">
                                <p class="text-lg">vruntime = (实际运行时间 × NICE_0_LOAD) / 进程权重</p>
                            </div>
                            <p>其中，<code>NICE_0_LOAD</code>是优先级为0时的权重常数（通常为1024）。权重越高，vruntime增长越慢，从而获得更多的CPU时间。</p>
                        </div>
                        
                        <div>
                            <h4 class="text-xl font-bold mb-2">CFS的运行队列</h4>
                            <p class="mb-4">CFS使用红黑树作为运行队列，按vruntime排序，vruntime最小的进程（即获得CPU时间最少的进程）在树的最左侧，这将是下一个被调度的进程。</p>
                            
                            <pre class="code-block"><code class="language-c">struct cfs_rq {
    struct load_weight load;    /* 队列中所有进程的总权重 */
    unsigned int nr_running;    /* 队列中可运行进程的数量 */
    
    u64 min_vruntime;           /* 跟踪最小vruntime，防止溢出 */
    struct rb_root tasks_timeline; /* 根据vruntime排序的红黑树 */
    struct rb_node *rb_leftmost; /* 缓存最左边的节点 */
    
    struct sched_entity *curr;  /* 当前正在运行的调度实体 */
    /* ... 其他字段 ... */
};</code></pre>
                            
                            <div class="mt-4">
                                <h4 class="text-xl font-bold mb-2">关键操作</h4>
                                <ul class="list-disc list-inside space-y-1">
                                    <li>入队(enqueue_entity)</li>
                                    <li>出队(dequeue_entity)</li>
                                    <li>选择下一个运行的进程(pick_next_entity)</li>
                                    <li>检查是否需要抢占(check_preempt_curr)</li>
                                    <li>更新当前进程统计信息(update_curr)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="mt-8">
                <div class="rounded-3xl bg-white shadow-lg p-8">
                    <h3 class="text-2xl font-bold mb-4">CFS调度器代码示例</h3>
                    
                    <pre class="code-block"><code class="language-c">static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq,struct sched_entity *curr)
{
    struct sched_entity *left = __pick_first_entity(cfs_rq);
    struct sched_entity *se;
    
    // 如果当前没有运行的进程，或者红黑树为空，返回NULL
    if (!left || (curr && entity_before(curr, left)))
        return NULL;
    
    // 从红黑树中选择vruntime最小的进程
    se = left;
    
    // ...省略了一些逻辑...
    
    return se;
}</code></pre>

                    <h3 class="text-2xl font-bold mb-4 mt-8">实时调度器</h3>
                    <p class="mb-4">对于实时进程，Linux使用<code>rt_sched_class</code>调度类，实现在<code>kernel/sched/rt.c</code>中。实时调度器支持两种调度策略：</p>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div class="bg-gray-100 p-6 rounded-xl">
                            <h4 class="text-xl font-bold mb-2 text-secondary">SCHED_FIFO</h4>
                            <p>先进先出调度策略，一旦获得CPU，进程将一直运行，直到主动放弃、阻塞或被更高优先级的实时进程抢占。</p>
                        </div>
                        
                        <div class="bg-gray-100 p-6 rounded-xl">
                            <h4 class="text-xl font-bold mb-2 text-secondary">SCHED_RR</h4>
                            <p>时间片轮转调度策略，类似于SCHED_FIFO，但每个进程有时间配额。</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>
        
        <!-- IPC Section -->
        <section id="ipc" class="section mb-32">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    进程间通信
                    <span class="block text-base font-normal text-secondary mt-2">INTER-PROCESS COMMUNICATION</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                <div class="rounded-2xl bg-white shadow-lg p-6 hover:shadow-xl transition-all">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-full highlight-gradient flex items-center justify-center">
                            <span class="material-icons text-white">linear_scale</span>
                        </div>
                        <h3 class="text-xl font-bold">管道和命名管道</h3>
                    </div>
                    <p class="mb-4">管道是最基本的IPC机制，允许相关进程间的单向数据流。命名管道则允许不相关的进程通信。</p>
                    <pre class="code-block"><code class="language-c">static int do_pipe_flags(int __user *fildes, int flags)
{
    int fd[2];
    struct file *files[2];
    int error;
    
    // 创建管道文件
    error = create_pipe_files(files, flags);
    if (error)
        return error;
    
    // 分配文件描述符
    error = get_unused_fd_flags(flags);
    // ... 省略部分代码 ...
}</code></pre>
                </div>
                
                <div class="rounded-2xl bg-white shadow-lg p-6 hover:shadow-xl transition-all">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-full accent-gradient flex items-center justify-center">
                            <span class="material-icons text-white">notifications_active</span>
                        </div>
                        <h3 class="text-xl font-bold">信号</h3>
                    </div>
                    <p class="mb-4">信号用于通知进程发生了某个事件，是一种异步通信机制。</p>
                    <pre class="code-block"><code class="language-c">SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)
{
    struct siginfo info;
    
    info.si_signo = sig;
    info.si_errno = 0;
    info.si_code = SI_USER;
    info.si_pid = task_tgid_vnr(current);
    info.si_uid = from_kuid_munged(current_user_ns(), current_uid());
    
    return kill_something_info(sig, &info, pid);
}</code></pre>
                </div>
                
                <div class="rounded-2xl bg-white shadow-lg p-6 hover:shadow-xl transition-all">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-full gradient-bg flex items-center justify-center">
                            <span class="material-icons text-white">memory</span>
                        </div>
                        <h3 class="text-xl font-bold">共享内存</h3>
                    </div>
                    <p class="mb-4">共享内存允许多个进程访问同一块内存区域，是最快的IPC方式。</p>
                    <pre class="code-block"><code class="language-c">static int newseg(struct ipc_namespace *ns, struct ipc_params *params)
{
    key_t key = params->key;
    int shmflg = params->flg;
    size_t size = params->u.size;
    int error;
    struct shmid_kernel *shp;
    
    // 分配共享内存段描述符
    shp = kvmalloc(sizeof(*shp), GFP_KERNEL);
    // ... 省略部分代码 ...
}</code></pre>
                </div>
                
                <div class="rounded-2xl bg-white shadow-lg p-6 hover:shadow-xl transition-all">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-full highlight-gradient flex items-center justify-center">
                            <span class="material-icons text-white">lock</span>
                        </div>
                        <h3 class="text-xl font-bold">信号量</h3>
                    </div>
                    <p class="mb-4">信号量用于进程同步，控制多个进程对共享资源的访问。</p>
                    <pre class="code-block"><code class="language-c">SYSCALL_DEFINE4(semop, int, semid, struct sembuf __user *, tsops,
                unsigned, nsops, int, semflg)
{
    return do_semtimedop(semid, tsops, nsops, NULL, semflg);
}

static int do_semtimedop(int semid, struct sembuf __user *tsops,
                         unsigned nsops, const struct timespec *timeout,
                         int semflg)
{
    // ... 省略代码 ...
}</code></pre>
                </div>
                
                <div class="rounded-2xl bg-white shadow-lg p-6 hover:shadow-xl transition-all">
                    <div class="flex items-center gap-3 mb-4">
                        <div class="w-10 h-10 rounded-full accent-gradient flex items-center justify-center">
                            <span class="material-icons text-white">email</span>
                        </div>
                        <h3 class="text-xl font-bold">消息队列</h3>
                    </div>
                    <p class="mb-4">消息队列允许进程发送和接收消息。</p>
                    <pre class="code-block"><code class="language-c">SYSCALL_DEFINE5(msgsnd, int, msqid, struct msgbuf __user *, msgp, size_t, msgsz,
                int, msgflg, int, msgtyp)
{
    long mtype;
    struct msg_queue *msq;
    struct msg_msg *msg;
    int err;
    
    // 获取消息类型
    if (get_user(mtype, &msgp->mtype))
        return -EFAULT;
    // ... 省略部分代码 ...
}</code></pre>
                </div>
            </div>
        </section>
        
        <!-- Process Synchronization Section -->
        <section id="synchronization" class="section mb-32">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    进程同步
                    <span class="block text-base font-normal text-secondary mt-2">SYNCHRONIZATION</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="bento-grid">
                <div class="col-span-12 mb-8 rounded-3xl light-gradient p-8">
                    <div class="mega-text text-primary opacity-10 absolute right-8 top-0">SYNC</div>
                    <h3 class="text-3xl font-bold text-primary mb-6 relative z-10">锁机制</h3>
                    
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                        <div>
                            <h4 class="text-xl font-bold mb-4">自旋锁</h4>
                            <p class="mb-4">自旋锁是一种在等待获取锁时"自旋"（忙等）的锁机制，适用于锁持有时间短的情况。在<code>include/linux/spinlock.h</code>中定义：</p>
                            
                            <pre class="code-block"><code class="language-c">typedef struct {
    raw_spinlock_t raw_lock;
} spinlock_t;

static inline void spin_lock(spinlock_t *lock)
{
    raw_spin_lock(&lock->raw_lock);
}

static inline void spin_unlock(spinlock_t *lock)
{
    raw_spin_unlock(&lock->raw_lock);
}</code></pre>
                        </div>
                        
                        <div>
                            <h4 class="text-xl font-bold mb-4">互斥锁</h4>
                            <p class="mb-4">互斥锁（mutex）与自旋锁不同，当无法获得锁时会使进程睡眠，适用于锁持有时间较长的情况。在<code>include/linux/mutex.h</code>中定义：</p>
                            
                            <pre class="code-block"><code class="language-c">struct mutex {
    atomic_long_t owner;
    spinlock_t wait_lock;
    struct list_head wait_list;
};

void mutex_lock(struct mutex *lock)
{
    might_sleep();
    if (!__mutex_trylock_fast(lock))
        __mutex_lock_slowpath(lock);
}

void mutex_unlock(struct mutex *lock)
{
    __mutex_unlock_slowpath(lock, _RET_IP_);
}</code></pre>
                        </div>
                    </div>
                </div>
                
                <div class="col-span-12 md:col-span-6 rounded-3xl bg-white shadow-lg p-8">
                    <h3 class="text-2xl font-bold mb-4">原子操作</h3>
                    <p class="mb-4">内核提供了原子操作来避免竞态条件，这些操作在单一指令中完成，不会被中断。在<code>include/linux/atomic.h</code>中定义：</p>
                    
                    <pre class="code-block"><code class="language-c">typedef struct {
    int counter;
} atomic_t;

static inline void atomic_inc(atomic_t *v)
{
    atomic_add(1, v);
}

static inline void atomic_dec(atomic_t *v)
{
    atomic_sub(1, v);
}

static inline bool atomic_dec_and_test(atomic_t *v)
{
    return atomic_dec_return(v) == 0;
}</code></pre>
                </div>
                
                <div class="col-span-12 md:col-span-6 rounded-3xl bg-white shadow-lg p-8">
                    <h3 class="text-2xl font-bold mb-4">读写锁</h3>
                    <p class="mb-4">读写锁允许多个读者同时访问共享资源，但写者必须独占。在<code>include/linux/rwlock.h</code>中定义：</p>
                    
                    <pre class="code-block"><code class="language-c">typedef struct {
    arch_rwlock_t raw_lock;
} rwlock_t;

static inline void read_lock(rwlock_t *lock)
{
    _raw_read_lock(&lock->raw_lock);
}

static inline void write_lock(rwlock_t *lock)
{
    _raw_write_lock(&lock->raw_lock);
}</code></pre>
                </div>
            </div>
        </section>
        
        <!-- Summary Section -->
        <section id="summary" class="section mb-16">
            <div class="mb-12">
                <h2 class="text-5xl md:text-6xl font-bold text-primary">
                    总结
                    <span class="block text-base font-normal text-secondary mt-2">SUMMARY</span>
                </h2>
                <div class="thin-line my-4"></div>
            </div>
            
            <div class="rounded-3xl gradient-bg p-8 text-white">
                <p class="text-lg mb-6">Linux进程管理子系统是内核的核心部分，它提供了进程创建、调度、通信和同步等基本功能。通过分析内核源代码，我们了解了以下关键概念：</p>
                
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <span class="material-icons text-4xl mb-2">account_circle</span>
                        <h4 class="text-xl font-bold mb-2">进程表示</h4>
                        <p>每个进程由<code>task_struct</code>结构体表示，包含进程的所有信息</p>
                    </div>
                    
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <span class="material-icons text-4xl mb-2">queue</span>
                        <h4 class="text-xl font-bold mb-2">进程创建</h4>
                        <p>通过<code>fork</code>、<code>exec</code>等系统调用创建和管理进程</p>
                    </div>
                    
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <span class="material-icons text-4xl mb-2">schedule</span>
                        <h4 class="text-xl font-bold mb-2">进程调度</h4>
                        <p>使用调度类和不同的调度策略，如CFS和实时调度器，实现公平高效的CPU分配</p>
                    </div>
                    
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <span class="material-icons text-4xl mb-2">swap_horiz</span>
                        <h4 class="text-xl font-bold mb-2">进程间通信</h4>
                        <p>提供多种IPC机制，如管道、信号、共享内存等</p>
                    </div>
                    
                    <div class="bg-white bg-opacity-10 rounded-xl p-6">
                        <span class="material-icons text-4xl mb-2">lock_outline</span>
                        <h4 class="text-xl font-bold mb-2">进程同步</h4>
                        <p>使用锁、原子操作等机制确保多进程环境下的安全操作</p>
                    </div>
                </div>
                
                <p class="text-lg mt-8">Linux进程管理子系统的精巧设计和高效实现，使Linux能够在从嵌入式设备到超级计算机的各种硬件平台上提供出色的性能和可靠性。掌握进程管理子系统的内部机制，对于理解Linux内核以及进行系统优化和调试都至关重要。</p>
            </div>
        </section>
    </main>
    
    <footer class="gradient-bg text-white py-16">
        <div class="container mx-auto px-4">
            <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                <div>
                    <h3 class="text-2xl font-bold mb-4">LINUX<br/>进程管理子系统</h3>
                    <p class="text-sm opacity-70">源码解析与深入理解</p>
                </div>
                
                <div>
                    <h4 class="text-lg font-bold mb-4">章节导航</h4>
                    <ul class="space-y-2">
                        <li><a href="#overview" class="hover:text-secondary transition-colors">概述</a></li>
                        <li><a href="#representation" class="hover:text-secondary transition-colors">进程的表示与组织</a></li>
                        <li><a href="#creation" class="hover:text-secondary transition-colors">进程的创建与终止</a></li>
                        <li><a href="#scheduling" class="hover:text-secondary transition-colors">进程调度</a></li>
                        <li><a href="#ipc" class="hover:text-secondary transition-colors">进程间通信</a></li>
                        <li><a href="#synchronization" class="hover:text-secondary transition-colors">进程同步</a></li>
                    </ul>
                </div>
                
                <div>
                    <h4 class="text-lg font-bold mb-4">延伸阅读</h4>
                    <ul class="space-y-2">
                        <li>《深入理解Linux内核》</li>
                        <li>《Linux内核设计与实现》</li>
                        <li>Linux内核源码 <a href="https://github.com/torvalds/linux" class="text-secondary hover:underline" target="_blank">GitHub</a></li>
                    </ul>
                </div>
            </div>
            <div class="thin-line my-8"></div>
            <p class="text-center text-sm opacity-70">Linux是一个开源操作系统，其源码遵循GNU通用公共许可证</p>
        </div>
    </footer>
    
    <script>
        // Smooth scroll for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                const targetId = this.getAttribute('href');
                document.querySelector(targetId).scrollIntoView({
                    behavior: 'smooth'
                });
            });
        });
        
        // Intersection Observer for section animations
        const sections = document.querySelectorAll('.section');
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('active');
                }
            });
        }, {
            threshold: 0.1
        });
        
        sections.forEach(section => {
            observer.observe(section);
        });
        
        // Initialize Framer Motion
        const { motion, useAnimation, useMotionValue } = window.FramerMotion;
        
        // Create architecture SVG diagram
        const createArchitectureDiagram = () => {
            const diagram = document.getElementById('architecture-diagram');
            
            // Create SVG for architecture diagram
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', '100%');
            svg.setAttribute('height', '100%');
            svg.setAttribute('viewBox', '0 0 800 400');
            
            const mainCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            mainCircle.setAttribute('cx', '400');
            mainCircle.setAttribute('cy', '200');
            mainCircle.setAttribute('r', '120');
            mainCircle.setAttribute('fill', 'none');
            mainCircle.setAttribute('stroke', '#445566');
            mainCircle.setAttribute('stroke-width', '2');
            svg.appendChild(mainCircle);
            
            // Core text
            const coreText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            coreText.setAttribute('x', '400');
            coreText.setAttribute('y', '200');
            coreText.setAttribute('text-anchor', 'middle');
            coreText.setAttribute('dominant-baseline', 'middle');
            coreText.setAttribute('font-size', '24');
            coreText.setAttribute('font-weight', 'bold');
            coreText.setAttribute('fill', '#445566');
            coreText.textContent = 'Linux进程管理';
            svg.appendChild(coreText);
            
            // Add subsystems
            const subsystems = [
                { name: '进程表示', angle: 0 },
                { name: '进程创建', angle: 72 },
                { name: '进程调度', angle: 144 },
                { name: '进程通信', angle: 216 },
                { name: '进程同步', angle: 288 }
            ];
            
            subsystems.forEach(system => {
                const angle = system.angle * Math.PI / 180;
                const x = 400 + 200 * Math.cos(angle);
                const y = 200 + 200 * Math.sin(angle);
                
                // Connecting line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 400 + 120 * Math.cos(angle));
                line.setAttribute('y1', 200 + 120 * Math.sin(angle));
                line.setAttribute('x2', x);
                line.setAttribute('y2', y);
                line.setAttribute('stroke', '#445566');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);
                
                // Subsystem circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', x);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', '50');
                circle.setAttribute('fill', system.name === '进程调度' ? '#E65D2E' : '#F5E6D3');
                circle.setAttribute('stroke', '#445566');
                circle.setAttribute('stroke-width', '1');
                svg.appendChild(circle);
                
                // Subsystem text
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', x);
                text.setAttribute('y', y);
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.setAttribute('font-size', '16');
                text.setAttribute('font-weight', 'bold');
                text.setAttribute('fill', system.name === '进程调度' ? '#FFFFFF' : '#445566');
                text.textContent = system.name;
                svg.appendChild(text);
            });
            
            diagram.appendChild(svg);
        };
        
        // Call functions after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            createArchitectureDiagram();
            
            // Add scroll-triggered animations
            document.addEventListener('scroll', () => {
                const scrollY = window.scrollY;
                const windowHeight = window.innerHeight;
                const documentHeight = document.body.scrollHeight;
                const scrollPercentage = scrollY / (documentHeight - windowHeight);
                
                // Parallax effect for different elements
                document.querySelectorAll('.parallax-element').forEach(element => {
                    const speed = element.dataset.speed || 0.5;
                    element.style.transform = `translateY(${scrollY * speed}px)`;
                });
            });
        });
    </script>
</body>
</html>