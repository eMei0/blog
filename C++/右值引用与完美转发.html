<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ 右值与右值引用深度解析</title>
    
    <!-- TailwindCSS -->
    <script src="https://fastly.jsdelivr.net/npm/tailwindcss@3.3.0/lib/index.min.js"></script>
    
    <!-- Framer Motion -->
    <script src="https://fastly.jsdelivr.net/npm/framer-motion@10.12.4/dist/framer-motion.js"></script>
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    
    <!-- ECharts -->
    <script src="https://fastly.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js"></script>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=Noto+Sans+SC:wght@300;400;500;700;900&display=swap');
        
        :root {
            --primary: #2563eb;
            --secondary: #6366f1;
            --accent: #10b981;
            --dark: #1e293b;
            --light: #f8fafc;
        }
        
        html {
            scroll-behavior: smooth;
        }
        
        body {
            font-family: 'Noto Sans SC', 'Inter', sans-serif;
            background-color: var(--light);
            color: var(--dark);
            overflow-x: hidden;
        }
        
        .gradient-bg {
            background: linear-gradient(120deg, rgba(37, 99, 235, 0.05), rgba(99, 102, 241, 0.08));
        }
        
        .accent-gradient {
            background: linear-gradient(120deg, rgba(16, 185, 129, 0.7), rgba(16, 185, 129, 0.9));
        }
        
        .primary-gradient {
            background: linear-gradient(120deg, rgba(37, 99, 235, 0.7), rgba(37, 99, 235, 0.9));
        }
        
        .secondary-gradient {
            background: linear-gradient(120deg, rgba(99, 102, 241, 0.7), rgba(99, 102, 241, 0.9));
        }
        
        .bento-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 1.5rem;
        }
        
        .reveal-section {
            opacity: 0;
            transform: translateY(50px);
            transition: all 0.8s ease;
        }
        
        .reveal-section.active {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tech-highlight {
            position: relative;
            overflow: hidden;
        }
        
        .tech-highlight::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(
                to right, 
                rgba(255, 255, 255, 0) 0%,
                rgba(255, 255, 255, 0.3) 50%,
                rgba(255, 255, 255, 0) 100%
            );
            transform: rotate(45deg);
            animation: shine 4s infinite;
        }
        
        @keyframes shine {
            0% { transform: translateX(-100%) rotate(45deg); }
            100% { transform: translateX(100%) rotate(45deg); }
        }
        
        code {
            font-family: 'Consolas', 'Monaco', monospace;
            padding: 0.15rem 0.3rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
            background-color: rgba(30, 41, 59, 0.05);
        }
        
        pre {
            overflow-x: auto;
            border-radius: 0.5rem;
            padding: 1.5rem;
            background-color: var(--dark);
            color: var(--light);
            margin: 1.5rem 0;
        }
        
        .mega-text {
            font-size: clamp(3rem, 15vw, 12rem);
            font-weight: 900;
            line-height: 0.9;
            letter-spacing: -0.05em;
        }
        
        .line-chart {
            height: 300px;
            width: 100%;
        }
    </style>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <nav id="cd414c1e-e265-4de5-88eb-25e5019281e9" class="fixed w-full bg-white bg-opacity-90 backdrop-blur-sm z-50 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between h-16">
                <div class="flex items-center">
                    <span class="font-bold text-xl text-blue-600">C++深度解析</span>
                </div>
                <div class="hidden md:flex items-center space-x-8">
                    <a href="#concept" class="text-sm font-medium text-gray-700 hover:text-blue-600 transition-colors duration-300">右值概念</a>
                    <a href="#reference" class="text-sm font-medium text-gray-700 hover:text-blue-600 transition-colors duration-300">右值引用</a>
                    <a href="#applications" class="text-sm font-medium text-gray-700 hover:text-blue-600 transition-colors duration-300">应用场景</a>
                    <a href="#notes" class="text-sm font-medium text-gray-700 hover:text-blue-600 transition-colors duration-300">注意事项</a>
                    <a href="#cpp17" class="text-sm font-medium text-gray-700 hover:text-blue-600 transition-colors duration-300">C++17变化</a>
                </div>
            </div>
        </div>
    </nav>

    <header id="d8108cab-73ed-4d44-8cbc-c2d8e707b886" class="relative h-screen flex items-center overflow-hidden">
        <div class="absolute inset-0 bg-gradient-to-br from-blue-50 to-indigo-100 z-0"></div>
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 relative z-10">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <div class="space-y-6">
                    <h1 class="text-5xl md:text-6xl font-black text-gray-900">
                        <span class="block">掌握 C++ 中的</span>
                        <span class="block text-blue-600">右值引用</span>
                    </h1>
                    <p class="text-xl text-gray-600">深入理解现代 C++ 中最强大的性能优化机制</p>
                    <div class="flex space-x-4">
                        <button class="primary-gradient text-white px-6 py-3 rounded-lg font-medium shadow-lg hover:shadow-xl transition-all duration-300" onclick="scrollToSection('concept')">
                            开始探索
                        </button>
                        <a href="https://github.com" target="_blank" class="flex items-center px-6 py-3 rounded-lg font-medium border border-gray-300 hover:border-blue-500 transition-all duration-300">
                            <i class="fab fa-github mr-2"></i> 示例代码
                        </a>
                    </div>
                </div>
                <div class="relative h-64 md:h-96 tech-highlight">
                    <div class="absolute inset-0 flex items-center justify-center">
                        <div class="text-center">
                            <div class="mega-text text-blue-600 opacity-20">R&&</div>
                            <div class="absolute inset-0 flex items-center justify-center">
                                <div class="text-3xl md:text-5xl font-bold text-gray-800">右值引用</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="absolute bottom-8 left-1/2 transform -translate-x-1/2 animate-bounce">
            <i class="fas fa-chevron-down text-gray-400 text-2xl"></i>
        </div>
    </header>

    <main class="pt-16">
        <!-- 右值的概念 -->
        <section id="concept" class="reveal-section py-20 bg-white">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex flex-col md:flex-row justify-between items-start mb-16">
                    <div class="mb-8 md:mb-0">
                        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">右值的概念</h2>
                        <p class="text-lg text-gray-600 max-w-2xl">在C++中，表达式可以分为左值和右值。右值是临时的、不可寻址的对象，包括纯右值和亡值两种类型。</p>
                    </div>
                    <div class="mega-text text-blue-100">01</div>
                </div>

                <div class="bento-grid">
                    <!-- 纯右值 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">
                                纯右值 <span class="text-base font-normal text-gray-500">prvalue</span>
                            </h3>
                            <p class="text-gray-600">纯右值(Pure rvalue)是没有标识符、不可寻址的临时对象，通常是字面常量或表达式求值的中间结果。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <h4 class="text-lg font-semibold mb-2">特点：</h4>
                            <ul class="space-y-2 text-gray-600">
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    不可取地址（&5 是非法的）
                                </li>
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    只能出现在表达式右侧
                                </li>
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    无法被赋值
                                </li>
                            </ul>
                            <div class="mt-6">
                                <pre><code>// 纯右值示例
int x = 5;        // 5是纯右值
int y = x + 10;   // x+10是纯右值
int z = max(a,b); // max(a,b)返回值是纯右值
auto p = new int; // new int返回的指针是纯右值</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- 亡值 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">
                                亡值 <span class="text-base font-normal text-gray-500">xvalue</span>
                            </h3>
                            <p class="text-gray-600">亡值(eXpiring value)是即将被销毁但仍可被移动的对象，它既有右值特性又有左值特性。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <h4 class="text-lg font-semibold mb-2">特点：</h4>
                            <ul class="space-y-2 text-gray-600">
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    表示资源即将释放
                                </li>
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    可以被移动构造/赋值
                                </li>
                                <li class="flex items-center">
                                    <i class="fas fa-circle text-blue-500 text-xs mr-2"></i>
                                    通常由std::move产生
                                </li>
                            </ul>
                            <div class="mt-6">
                                <pre><code>// 亡值示例
std::string str = "hello";
std::string&& r = std::move(str); // std::move(str)是亡值
auto v = std::vector<int>{1, 2, 3};
processVector(std::move(v));      // std::move(v)是亡值</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- 值类别图表 -->
                    <div class="col-span-12 bg-white rounded-3xl p-8 shadow-lg mt-8">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">C++ 值类别体系</h3>
                        <div class="h-80" id="value-category-chart"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 右值引用 -->
        <section id="reference" class="reveal-section py-20 bg-gray-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex flex-col md:flex-row justify-between items-start mb-16">
                    <div class="mb-8 md:mb-0">
                        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">右值引用</h2>
                        <p class="text-lg text-gray-600 max-w-2xl">右值引用是C++11引入的一种新的引用类型，用于绑定到右值。它是移动语义和完美转发的基础。</p>
                    </div>
                    <div class="mega-text text-blue-100">02</div>
                </div>

                <div class="bento-grid">
                    <!-- 基本语法 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">右值引用的基本语法</h3>
                            <p class="text-gray-600">右值引用使用双与符号(&&)声明，它只能绑定到右值上。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <pre><code>// 右值引用语法
int&& a = 5;             // 正确: 5是右值
int b = 10;
int&& c = b;             // 错误: b是左值，不能绑定到右值引用
int&& d = std::move(b);  // 正确: std::move将b转换为右值引用

// 函数返回右值引用
int&& func() {
    return 42;  // 返回临时值的右值引用
}

// 函数参数中使用右值引用
void process(int&& val) {
    // val在这里是一个命名的右值引用
    // 注意: 命名的右值引用本身是左值!
}</code></pre>
                        </div>
                    </div>

                    <!-- 特性 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">右值引用的特性</h3>
                            <p class="text-gray-600">右值引用具有一些独特的特性，理解这些特性对于使用移动语义至关重要。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <ul class="space-y-4 text-gray-600">
                                <li class="flex items-start">
                                    <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                    <div>
                                        <span class="font-semibold">延长生命周期</span> - 绑定到右值的右值引用会延长临时对象的生命周期
                                    </div>
                                </li>
                                <li class="flex items-start">
                                    <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                    <div>
                                        <span class="font-semibold">只能绑定右值</span> - 无法直接绑定到左值（除非使用std::move）
                                    </div>
                                </li>
                                <li class="flex items-start">
                                    <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                    <div>
                                        <span class="font-semibold">引用折叠</span> - 在模板和类型推导中有特殊规则
                                    </div>
                                </li>
                                <li class="flex items-start">
                                    <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                    <div>
                                        <span class="font-semibold">命名悖论</span> - 一旦右值引用被命名，它就变成了一个左值
                                    </div>
                                </li>
                            </ul>
                        </div>
                    </div>

                    <!-- 右值引用与左值 -->
                    <div class="col-span-12 gradient-bg rounded-3xl p-8 shadow-lg mt-8">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">右值引用与左值的关系</h3>
                            <p class="text-gray-600">命名的右值引用本身是左值，这一点经常被忽视但非常重要。</p>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">命名悖论演示</h4>
                                <pre><code>void foo(int&& x) {
    // x是右值引用，但它本身是一个左值
    // 因为它有名字，可以取地址
    bar(x);         // 传递x作为左值
    bar(std::move(x)); // 正确: 再次将x转为右值
}

void bar(int& x) {
    std::cout << "左值引用: " << x << std::endl;
}

void bar(int&& x) {
    std::cout << "右值引用: " << x << std::endl;
}</code></pre>
                            </div>
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">引用折叠规则</h4>
                                <p class="mb-4">C++中的引用折叠规则：</p>
                                <ul class="space-y-2 text-gray-600">
                                    <li>T& & → T&</li>
                                    <li>T& && → T&</li>
                                    <li>T&& & → T&</li>
                                    <li>T&& && → T&&</li>
                                </ul>
                                <p class="mt-4">这些规则对于理解完美转发至关重要。只有当两个都是右值引用时，结果才是右值引用。</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 应用场景 -->
        <section id="applications" class="reveal-section py-20 bg-white">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex flex-col md:flex-row justify-between items-start mb-16">
                    <div class="mb-8 md:mb-0">
                        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">右值引用的应用</h2>
                        <p class="text-lg text-gray-600 max-w-2xl">右值引用的主要应用是实现移动语义和完美转发，这两个特性是现代C++性能优化的基石。</p>
                    </div>
                    <div class="mega-text text-blue-100">03</div>
                </div>

                <div class="bento-grid">
                    <!-- 移动语义 -->
                    <div class="col-span-12 md:col-span-7 gradient-bg rounded-3xl p-8 shadow-lg">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">移动语义</h3>
                            <p class="text-gray-600">移动语义允许将资源从一个对象转移到另一个对象，而不是进行深拷贝，从而提高性能。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <h4 class="text-lg font-semibold mb-4">移动构造函数示例</h4>
                            <pre><code>class MyString {
private:
    char* data;
    size_t length;

public:
    // 构造函数
    MyString(const char* str) {
        length = strlen(str);
        data = new char[length + 1];
        memcpy(data, str, length + 1);
    }

    // 拷贝构造函数
    MyString(const MyString& other) {
        length = other.length;
        data = new char[length + 1];
        memcpy(data, other.data, length + 1);
        std::cout << "拷贝构造" << std::endl;
    }

    // 移动构造函数
    MyString(MyString&& other) noexcept {
        // 窃取资源
        data = other.data;
        length = other.length;
        
        // 将源对象置为安全状态
        other.data = nullptr;
        other.length = 0;
        
        std::cout << "移动构造" << std::endl;
    }

    // 析构函数
    ~MyString() {
        delete[] data;
    }
};</code></pre>
                        <div class="mt-6">
                            <h4 class="text-lg font-semibold mb-4">使用移动语义</h4>
                            <pre><code>// 使用移动语义
MyString createString() {
    MyString temp("Temporary String");
    return temp;  // 这里会触发移动而非复制
}

int main() {
    MyString a("Hello");
    
    // 拷贝构造
    MyString b(a);
    
    // 移动构造
    MyString c(std::move(a));  // a现在处于有效但未指定的状态
    
    // 从函数返回值进行移动构造
    MyString d(createString());
    
    // 不要再使用a的值
    // a.data现在是nullptr
    
    return 0;
}</code></pre>
                        </div>
                        </div>
                    </div>

                    <!-- 移动性能对比 -->
                    <div class="col-span-12 md:col-span-5 bg-white rounded-3xl p-8 shadow-lg">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">移动与拷贝性能对比</h3>
                        <div class="h-96" id="performance-chart"></div>
                        <div class="mt-6 text-sm text-gray-500">
                            <p>*数据基于1GB大小的std::vector&lt;int&gt;与std::string实验测量，单位为毫秒。</p>
                        </div>
                    </div>

                    <!-- 完美转发 -->
                    <div class="col-span-12 gradient-bg rounded-3xl p-8 shadow-lg mt-8">
                        <div class="mb-8">
                            <h3 class="text-2xl font-bold text-gray-800 mb-4">完美转发</h3>
                            <p class="text-gray-600">完美转发允许函数模板将参数按照原始类型（保持左值/右值特性）转发给其他函数。</p>
                        </div>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <h4 class="text-lg font-semibold mb-4">完美转发原理</h4>
                            <p class="mb-4">完美转发通过std::forward结合通用引用(T&&)实现：</p>
                            <pre><code>// 完美转发示例
template&lt;typename T&gt;
void wrapper(T&& arg) {
    // std::forward保持arg的值类别
    // 如果arg是右值，则转发为右值
    // 如果arg是左值，则转发为左值
    helper(std::forward<T>(arg));
}

// 接收左值引用的重载
void helper(const std::string& s) {
    std::cout << "左值引用: " << s << std::endl;
}

// 接收右值引用的重载
void helper(std::string&& s) {
    std::cout << "右值引用: " << s << std::endl;
}

int main() {
    std::string str = "Hello";
    
    wrapper(str);             // 调用 helper(const std::string&)
    wrapper(std::move(str));  // 调用 helper(std::string&&)
    wrapper(std::string("Temporary")); // 调用 helper(string&&)
    
    return 0;
}</code></pre>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mt-8">
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">通用引用</h4>
                                <p>通用引用(Universal Reference)是Scott Meyers提出的概念，表示既可以绑定到左值也可以绑定到右值的引用：</p>
                                <ul class="mt-4 space-y-2 text-gray-600">
                                    <li class="flex items-start">
                                        <i class="fas fa-circle text-blue-500 text-xs mt-1.5 mr-2"></i>
                                        <div>形式为<code>T&&</code>，其中T是推导类型</div>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fas fa-circle text-blue-500 text-xs mt-1.5 mr-2"></i>
                                        <div>常见于函数模板参数和auto&&声明</div>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fas fa-circle text-blue-500 text-xs mt-1.5 mr-2"></i>
                                        <div>利用引用折叠规则确定最终引用类型</div>
                                    </li>
                                </ul>
                            </div>
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">完美转发的应用</h4>
                                <ul class="space-y-3 text-gray-600">
                                    <li class="flex items-start">
                                        <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                        <div>
                                            <span class="font-semibold">工厂函数模式</span> - 创建对象时转发构造函数参数
                                        </div>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                        <div>
                                            <span class="font-semibold">包装器和代理</span> - 委托函数调用而保持参数类型
                                        </div>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                        <div>
                                            <span class="font-semibold">std::thread</span> - 传递函数参数
                                        </div>
                                    </li>
                                    <li class="flex items-start">
                                        <i class="fas fa-check-circle text-green-500 mt-1 mr-2"></i>
                                        <div>
                                            <span class="font-semibold">容器emplace操作</span> - 原地构造元素
                                        </div>
                                    </li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 注意事项 -->
        <section id="notes" class="reveal-section py-20 bg-gray-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex flex-col md:flex-row justify-between items-start mb-16">
                    <div class="mb-8 md:mb-0">
                        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">注意事项</h2>
                        <p class="text-lg text-gray-600 max-w-2xl">使用右值引用和移动语义时需要注意一些关键问题，避免常见陷阱。</p>
                    </div>
                    <div class="mega-text text-blue-100">04</div>
                </div>

                <div class="bento-grid">
                    <!-- 常见陷阱 -->
                    <div class="col-span-12 md:col-span-7 gradient-bg rounded-3xl p-8 shadow-lg">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">常见陷阱和最佳实践</h3>
                        <div class="space-y-8">
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">使用移动后的对象</h4>
                                <pre><code>std::string s1 = "Hello";
std::string s2 = std::move(s1);

// 危险: s1已被移动，处于有效但未指定状态
std::cout << s1 << std::endl;  // 可能输出空字符串或原始值

// 安全: 在使用前重新赋值
s1 = "World";
std::cout << s1 << std::endl;  // 现在安全</code></pre>
                                <div class="mt-4 flex items-start">
                                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1 mr-2"></i>
                                    <p class="text-sm text-gray-600">移后使用(use-after-move)是一种未定义行为，应当避免。被移动的对象处于"有效但未指定"的状态，只能重新赋值或销毁。</p>
                                </div>
                            </div>
                            
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">条件移动</h4>
                                <pre><code>template&lttypename T&gt
void conditionalProcess(T& value, bool shouldMove) {
    if (shouldMove) {
        helper(std::move(value));  // 移动语义
    } else {
        helper(value);             // 复制语义
    }
    
    // 危险: 如果shouldMove为true，value已被移动
    process(value);  // 可能使用已移动的对象
}</code></pre>
                                <div class="mt-4 flex items-start">
                                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1 mr-2"></i>
                                    <p class="text-sm text-gray-600">在条件分支中移动对象需要特别小心，确保在移动后不再使用原对象。</p>
                                </div>
                            </div>
                            
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-4">返回局部变量的引用</h4>
                                <pre><code>// 错误示例
std::string&& dangerous() {
    std::string local = "Danger";
    return std::move(local);  // 返回局部变量引用!
}

// 正确示例
std::string safe() {
    std::string local = "Safe";
    return local;  // 编译器会自动应用RVO或移动语义
}

// 阻碍RVO的错误示例
std::string blockingRVO() {
    std::string local = "No RVO";
    return std::move(local);  // 不要这样做!
}</code></pre>
                                <div class="mt-4 flex items-start">
                                    <i class="fas fa-exclamation-triangle text-yellow-500 mt-1 mr-2"></i>
                                    <p class="text-sm text-gray-600">返回局部对象时应依赖RVO(Return Value Optimization)，不要显式使用std::move，这反而会阻止优化。</p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- 最佳实践清单 -->
                    <div class="col-span-12 md:col-span-5 bg-white rounded-3xl p-8 shadow-lg">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">最佳实践清单</h3>
                        <ul class="space-y-6">
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">1</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">将移动构造/赋值标记为noexcept</h4>
                                    <p class="text-gray-600 mt-1">标记为noexcept可以启用容器的移动优化，如std::vector在重新分配时的行为。</p>
                                </div>
                            </li>
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">2</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">移动操作后将源对象置为有效状态</h4>
                                    <p class="text-gray-600 mt-1">被移动对象应处于可析构和再次赋值的有效状态，通常设置为零值或null。</p>
                                </div>
                            </li>
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">3</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">不要std::move局部返回值</h4>
                                    <p class="text-gray-600 mt-1">允许编译器应用RVO(返回值优化)，它比显式移动更高效。</p>
                                </div>
                            </li>
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">4</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">注意命名的右值引用是左值</h4>
                                    <p class="text-gray-600 mt-1">传递右值引用参数时，需要再次使用std::move才能保持右值语义。</p>
                                </div>
                            </li>
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">5</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">区分通用引用和右值引用</h4>
                                    <p class="text-gray-600 mt-1">T&& 在模板参数中是通用引用，可接受左值和右值；Class&& 则是右值引用。</p>
                                </div>
                            </li>
                            <li class="flex items-start">
                                <div class="bg-blue-500 text-white rounded-full w-8 h-8 flex items-center justify-center flex-shrink-0 mt-0.5">
                                    <span class="font-bold">6</span>
                                </div>
                                <div class="ml-4">
                                    <h4 class="text-lg font-semibold">重载函数时考虑通用引用的特殊性</h4>
                                    <p class="text-gray-600 mt-1">通用引用重载可能过于"贪婪"，导致意外匹配。考虑使用std::enable_if或概念(concepts)限制。</p>
                                </div>
                            </li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- C++17变化 -->
        <section id="cpp17" class="reveal-section py-20 bg-white">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex flex-col md:flex-row justify-between items-start mb-16">
                    <div class="mb-8 md:mb-0">
                        <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-4">右值引用与C++17的变化</h2>
                        <p class="text-lg text-gray-600 max-w-2xl">C++17进一步增强了右值引用和移动语义的使用场景和效率。</p>
                    </div>
                    <div class="mega-text text-blue-100">05</div>
                </div>

                <div class="bento-grid">
                    <!-- 保证的复制消除 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">保证的复制消除</h3>
                        <div class="bg-white rounded-xl p-6 shadow-inner">
                            <p class="mb-4">C++17之前，返回值优化(RVO)是编译器的可选优化。C++17保证了某些情况下的复制/移动消除：</p>
                            <pre><code>// C++17保证这种情况不会发生复制或移动
class Widget {
public:
    Widget() { std::cout << "构造器" << std::endl; }
    Widget(const Widget&) { std::cout << "拷贝" << std::endl; }
    Widget(Widget&&) { std::cout << "移动" << std::endl; }
};

Widget createWidget() {
    return Widget();  // 不会调用移动构造函数
}

Widget createNamedWidget() {
    Widget w;
    return w;  // 在C++17中保证不会调用移动构造函数
}

int main() {
    Widget w = createWidget();  // 只调用一次构造函数
    return 0;
}</code></pre>
                            <div class="mt-4">
                                <p class="text-sm text-gray-600">这种优化使得返回大型对象的函数更加高效，也让按值返回成为首选的惯用法。</p>
                            </div>
                        </div>
                    </div>

                    <!-- 其他C++17特性 -->
                    <div class="col-span-12 md:col-span-6 gradient-bg rounded-3xl p-8 shadow-lg">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">其他与右值相关的C++17特性</h3>
                        <div class="space-y-6">
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-2">结构化绑定</h4>
                                <pre><code>// 结构化绑定可以与右值配合使用
std::pair<int, std::string> getPair() {
    return {42, "hello"};
}

auto [value, name] = getPair();  // 无需复制，直接绑定</code></pre>
                            </div>
                            
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-2">if和switch中的初始化语句</h4>
                                <pre><code>// if中的初始化可以避免临时变量
if (auto [iter, success] = myMap.insert({key, value}); success) {
    // 使用iter，无需额外的移动或复制
} else {
    // 使用iter指向已存在的元素
}</code></pre>
                            </div>
                            
                            <div class="bg-white rounded-xl p-6 shadow-inner">
                                <h4 class="text-lg font-semibold mb-2">类模板参数推导</h4>
                                <pre><code>// C++17前
auto v1 = std::vector<int>{1, 2, 3};

// C++17后
std::vector v2{1, 2, 3};  // 自动推导为std::vector<int>

// 与右值结合使用
std::vector v3 = createVector();  // 移动构造而非复制</code></pre>
                            </div>
                        </div>
                    </div>

                    <!-- C++17移动语义优化 -->
                    <div class="col-span-12 bg-white rounded-3xl p-8 shadow-lg mt-8">
                        <h3 class="text-2xl font-bold text-gray-800 mb-6">移动语义在标准库中的增强</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                            <div class="border border-gray-200 rounded-xl p-6">
                                <h4 class="text-lg font-semibold mb-4">std::string_view</h4>
                                <p class="text-gray-600">非拥有型字符串视图，避免了不必要的std::string复制和移动：</p>
                                <pre><code>void process(std::string_view sv) {
    // 不会发生字符串的复制或移动
}

std::string s = "hello";
process(s);           // 无复制
process("literal");   // 无复制</code></pre>
                            </div>
                            
                            <div class="border border-gray-200 rounded-xl p-6">
                                <h4 class="text-lg font-semibold mb-4">std::optional</h4>
                                <p class="text-gray-600">可以存储"可能有值"的对象，支持移动语义：</p>
                                <pre><code>std::optional<std::vector<int>> 
    getValues() {
    if (hasData)
        return std::vector{1, 2, 3};
    return std::nullopt;
}

// 移动而非复制
auto values = getValues();</code></pre>
                            </div>
                            
                            <div class="border border-gray-200 rounded-xl p-6">
                                <h4 class="text-lg font-semibold mb-4">std::variant</h4>
                                <p class="text-gray-600">类型安全的联合体，支持移动语义：</p>
                                <pre><code>std::variant<std::string, int> 
    getVariant(bool useString) {
    if (useString)
        return std::string("hello");
    return 42;
}

// 高效地移动字符串
auto var = getVariant(true);</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- 总结 -->
        <section id="summary" class="reveal-section py-20 bg-gray-50">
            <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                <div class="text-center mb-12">
                    <h2 class="text-3xl md:text-4xl font-bold text-gray-900 mb-6">核心要点回顾</h2>
                    <p class="text-xl text-gray-600 max-w-3xl mx-auto">掌握右值引用是迈向现代C++高效编程的重要一步</p>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
                    <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300">
                        <div class="text-4xl text-blue-500 mb-4">
                            <i class="fas fa-bookmark"></i>
                        </div>
                        <h3 class="text-xl font-bold mb-4">右值是临时的</h3>
                        <p class="text-gray-600">理解右值的本质是临时对象，包括纯右值(prvalue)和亡值(xvalue)两种类型，它们都可以被右值引用绑定。</p>
                    </div>
                    
                    <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300">
                        <div class="text-4xl text-blue-500 mb-4">
                            <i class="fas fa-exchange-alt"></i>
                        </div>
                        <h3 class="text-xl font-bold mb-4">移动比复制更高效</h3>
                        <p class="text-gray-600">移动语义允许"窃取"即将销毁对象的资源，而不是复制它们，对于管理动态资源的类尤其重要。</p>
                    </div>
                    
                    <div class="bg-white rounded-3xl p-8 shadow-lg hover:shadow-xl transition-all duration-300">
                        <div class="text-4xl text-blue-500 mb-4">
                            <i class="fas fa-forward"></i>
                        </div>
                        <h3 class="text-xl font-bold mb-4">完美转发保留类型</h3>
                        <p class="text-gray-600">通过std::forward和通用引用(T&&)的配合，可以在传递参数时保持原始的值类别(左值/右值)，实现零开销抽象。</p>
                    </div>
                </div>

                <div class="mt-12 text-center">
                    <p class="text-xl text-gray-800 font-medium mb-8">继续学习的资源</p>
                    <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-6">
                        <a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" class="bg-white p-6 rounded-xl shadow hover:shadow-md transition-all flex flex-col items-center">
                            <i class="fas fa-book text-blue-500 text-2xl mb-3"></i>
                            <span class="text-gray-800">cppreference</span>
                        </a>
                        <a href="https://isocpp.org/" target="_blank" class="bg-white p-6 rounded-xl shadow hover:shadow-md transition-all flex flex-col items-center">
                            <i class="fas fa-code text-blue-500 text-2xl mb-3"></i>
                            <span class="text-gray-800">isocpp.org</span>
                        </a>
                        <a href="https://www.youtube.com/user/CppCon" target="_blank" class="bg-white p-6 rounded-xl shadow hover:shadow-md transition-all flex flex-col items-center">
                            <i class="fab fa-youtube text-blue-500 text-2xl mb-3"></i>
                            <span class="text-gray-800">CppCon</span>
                        </a>
                        <a href="https://github.com/topics/cpp" target="_blank" class="bg-white p-6 rounded-xl shadow hover:shadow-md transition-all flex flex-col items-center">
                            <i class="fab fa-github text-blue-500 text-2xl mb-3"></i>
                            <span class="text-gray-800">Github C++</span>
                        </a>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer id="e82c3d6f-674c-40a9-9cdb-1487f057bd9c" class="bg-gray-900 text-white py-12">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="grid grid-cols-1 md:grid-cols-2 gap-8 items-center">
                <div>
                    <h3 class="text-2xl font-bold mb-4">C++ 右值与右值引用深度解析</h3>
                    <p class="text-gray-400">本网页为现代C++特性详解系列的一部分</p>
                </div>
                <div class="text-right">
                    <p class="text-gray-400">© 2025 现代C++学习站点</p>
                    <div class="flex justify-end mt-4 space-x-4">
                        <a href="#" class="text-gray-400 hover:text-white transition-colors">
                            <i class="fab fa-github text-xl"></i>
                        </a>
                        <a href="#" class="text-gray-400 hover:text-white transition-colors">
                            <i class="fab fa-twitter text-xl"></i>
                        </a>
                        <a href="#" class="text-gray-400 hover:text-white transition-colors">
                            <i class="fab fa-linkedin text-xl"></i>
                        </a>
                    </div>
                </div>
            </div>
        </div>
    </footer>

    <script>
        // 滚动显示元素
        function revealSections() {
            const sections = document.querySelectorAll('.reveal-section');
            
            sections.forEach(section => {
                const sectionTop = section.getBoundingClientRect().top;
                const windowHeight = window.innerHeight;
                
                if (sectionTop < windowHeight * 0.85) {
                    section.classList.add('active');
                }
            });
        }

        // 平滑滚动到指定section
        function scrollToSection(id) {
            document.getElementById(id).scrollIntoView({
                behavior: 'smooth'
            });
        }
        
        // 初始化图表
        function initCharts() {
            // 值类别图表
            const valueCategoryChart = echarts.init(document.getElementById('value-category-chart'));
            const valueCategoryOption = {
                tooltip: {
                    trigger: 'item',
                    formatter: '{b}: {c}'
                },
                series: [
                    {
                        name: 'C++值类别',
                        type: 'tree',
                        data: [
                            {
                                name: '表达式',
                                children: [
                                    { 
                                        name: '左值(lvalue)',
                                        itemStyle: { color: '#1e40af' },
                                        children: [
                                            { name: '变量名', itemStyle: { color: '#1e40af' } },
                                            { name: '解引用指针', itemStyle: { color: '#1e40af' } },
                                            { name: '成员访问(.)', itemStyle: { color: '#1e40af' } }
                                        ]
                                    },
                                    {
                                        name: '右值(rvalue)',
                                        itemStyle: { color: '#3b82f6' },
                                        children: [
                                            { 
                                                name: '纯右值(prvalue)', 
                                                itemStyle: { color: '#60a5fa' },
                                                children: [
                                                    { name: '字面量', itemStyle: { color: '#60a5fa' } },
                                                    { name: '算术表达式', itemStyle: { color: '#60a5fa' } },
                                                    { name: 'this指针', itemStyle: { color: '#60a5fa' } }
                                                ] 
                                            },
                                            { 
                                                name: '亡值(xvalue)', 
                                                itemStyle: { color: '#93c5fd' },
                                                children: [
                                                    { name: 'std::move结果', itemStyle: { color: '#93c5fd' } },
                                                    { name: '临时对象成员引用', itemStyle: { color: '#93c5fd' } }
                                                ] 
                                            }
                                        ]
                                    }
                                ]
                            }
                        ],
                        top: '10%',
                        left: '20%',
                        bottom: '10%',
                        right: '20%',
                        symbolSize: 12,
                        orient: 'vertical',
                        label: {
                            position: 'left',
                            verticalAlign: 'middle',
                            align: 'right',
                            fontSize: 14
                        },
                        leaves: {
                            label: {
                                position: 'right',
                                verticalAlign: 'middle',
                                align: 'left'
                            }
                        },
                        expandAndCollapse: true,
                        animationDuration: 550,
                        animationDurationUpdate: 750
                    }
                ]
            };
            
            valueCategoryChart.setOption(valueCategoryOption);

            // 性能比较图表
            const performanceChart = echarts.init(document.getElementById('performance-chart'));
            const performanceOption = {
                title: {
                    text: '复制与移动性能对比',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    }
                },
                legend: {
                    data: ['复制操作', '移动操作'],
                    top: '10%',
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '10%',
                    top: '25%',
                    containLabel: true
                },
                xAxis: {
                    type: 'value',
                    name: '耗时(毫秒)',
                    axisLabel: {
                        formatter: '{value} ms'
                    }
                },
                yAxis: {
                    type: 'category',
                    data: ['std::string', 'std::vector', 'std::map', '自定义对象'],
                },
                series: [
                    {
                        name: '复制操作',
                        type: 'bar',
                        itemStyle: {
                            color: '#3b82f6'
                        },
                        data: [210, 890, 650, 430]
                    },
                    {
                        name: '移动操作',
                        type: 'bar',
                        itemStyle: {
                            color: '#10b981'
                        },
                        data: [15, 60, 120, 25]
                    }
                ]
            };
            
            performanceChart.setOption(performanceOption);
            
            // 响应窗口大小变化
            window.addEventListener('resize', () => {
                valueCategoryChart.resize();
                performanceChart.resize();
            });
        }
        
        // 页面加载完成后执行
        document.addEventListener('DOMContentLoaded', () => {
            revealSections();
            initCharts();
        });
        
        // 滚动时执行
        window.addEventListener('scroll', revealSections);
    </script>
</body>
</html>