<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>设计模式详解 | 优缺点、使用场景与C++实现</title>
    <link href="https://fastly.jsdelivr.net/npm/tailwindcss@3.3.3/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css">
    <script src="https://fastly.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/prismjs@1.29.0/components/prism-cpp.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700;900&family=Inter:wght@400;500;700;900&display=swap');

        :root {
            --primary-color: #3b82f6;
            --secondary-color: #8b5cf6;
            --accent-color: #10b981;
            --bg-color: #f9fafb;
            --text-color: #1f2937;
            --card-bg: #ffffff;
        }

        body {
            font-family: 'Noto Sans SC', 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
        }

        .hero-gradient {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
        }
        
        .card {
            border-radius: 16px;
            background-color: var(--card-bg);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            overflow: hidden;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
        }
        
        .number-accent {
            font-size: 120px;
            font-weight: 900;
            line-height: 1;
            opacity: 0.1;
            position: absolute;
            right: 20px;
            top: 10px;
        }
        
        .pattern-accent {
            font-weight: 900;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .primary-gradient {
            background: linear-gradient(90deg, var(--primary-color), var(--primary-color), rgba(59, 130, 246, 0.7));
        }
        
        .secondary-gradient {
            background: linear-gradient(90deg, var(--secondary-color), var(--secondary-color), rgba(139, 92, 246, 0.7));
        }
        
        .accent-gradient {
            background: linear-gradient(90deg, var(--accent-color), var(--accent-color), rgba(16, 185, 129, 0.7));
        }
        
        .chart-container {
            height: 300px;
            width: 100%;
            margin: 20px 0;
        }
        
        .code-block {
            border-radius: 8px;
            overflow: hidden;
        }
        
        .animated-element {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.6s ease, transform 0.6s ease;
        }
        
        .animated-element.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a1a1a1;
        }
        
        .nav-link {
            transition: all 0.3s ease;
            position: relative;
        }
        
        .nav-link:after {
            content: '';
            position: absolute;
            bottom: -4px;
            left: 0;
            width: 0;
            height: 2px;
            background: var(--primary-color);
            transition: width 0.3s ease;
        }
        
        .nav-link:hover:after {
            width: 100%;
        }
        
        .benefits-list li, .drawbacks-list li {
            margin-bottom: 10px;
            position: relative;
            padding-left: 28px;
        }
        
        .benefits-list i {
            color: var(--accent-color);
            position: absolute;
            left: 0;
            top: 3px;
        }
        
        .drawbacks-list i {
            color: #ef4444;
            position: absolute;
            left: 0;
            top: 3px;
        }
        
        @media (max-width: 768px) {
            .number-accent {
                font-size: 80px;
                top: 0;
                right: 10px;
            }
        }
    </style>
<script src="https://cdn.tailwindcss.com"></script>
</head>
<body>
    <!-- 导航栏 -->
    <header id="e77a0f3d-3c0f-44d2-b0e1-50e04a007438" class="sticky top-0 z-50 bg-white shadow-sm">
        <nav id="5d88cd46-1f5e-480a-9d9e-a11eb4fc34d7" class="container mx-auto px-4 md:px-6 py-4 flex justify-between items-center">
            <div id="af6e4dca-0621-4321-b62d-23ef355e5279" class="flex items-center">
                <span id="e1e9f1b8-af45-48c3-ae1c-b65ad10257af" class="text-2xl font-bold pattern-accent">Design Patterns</span>
                <span id="5f253884-a421-4d5f-99df-fb7ce1b2bbdb" class="ml-2 text-gray-600 hidden md:block">| 设计模式详解</span>
            </div>
            <div id="b0fbc180-3a30-4889-b0f7-b6075171da96" class="hidden md:flex space-x-6">
                <a href="#intro" id="b39a1b5a-49e3-4769-a4c9-fa8d380218a7" class="nav-link text-gray-600 hover:text-primary-600">简介</a>
                <a href="#patterns" id="4adbfd38-9b35-478b-9c1a-c9974f437c75" class="nav-link text-gray-600 hover:text-primary-600">设计模式</a>
                <a href="#guide" id="0976eedb-5f02-4ea9-9b23-d99ec583901a" class="nav-link text-gray-600 hover:text-primary-600">选择指南</a>
            </div>
            <button id="6d91ba5c-12c6-4e79-a4f0-383fc67cf816" class="md:hidden text-gray-600">
                <i class="fas fa-bars"></i>
            </button>
        </nav>
    </header>

    <!-- 移动导航菜单 -->
    <div id="mobile-menu" class="fixed inset-0 bg-white z-40 flex-col p-6 hidden">
        <div id="bd1baeb0-9837-4f66-a342-4da0bdb08301" class="flex justify-between items-center mb-8">
            <span id="c2ebb89e-79ec-424a-9bd7-1c7acf5e9acc" class="text-2xl font-bold pattern-accent">Design Patterns</span>
            <button id="close-menu" class="text-gray-600">
                <i class="fas fa-times"></i>
            </button>
        </div>
        <div id="2967921f-787c-4e12-81d1-a15570deb3f0" class="flex flex-col space-y-6">
            <a href="#intro" id="e6f4abdd-af97-4252-b744-6cce81422f16" class="text-lg text-gray-600 hover:text-primary-600">简介</a>
            <a href="#patterns" id="c946c39e-13c2-4a42-8a5e-0c761521597e" class="text-lg text-gray-600 hover:text-primary-600">设计模式</a>
            <a href="#guide" id="0c2e59a3-7760-48e3-a55b-be87d7407e7c" class="text-lg text-gray-600 hover:text-primary-600">选择指南</a>
        </div>
    </div>

    <!-- 英雄区域 -->
    <section id="hero" class="hero-gradient py-20 md:py-32 relative overflow-hidden">
        <div id="a9661836-4903-4e8b-a52b-063f8f9a60c8" class="container mx-auto px-4 md:px-6">
            <div id="ffd9660b-e80a-4041-a4d0-c4e5780e615b" class="animated-element max-w-4xl mx-auto text-center">
                <h1 id="d06a0fc1-9a61-46c5-a9ab-07c08a16e723" class="text-4xl md:text-6xl font-black mb-6 leading-tight">
                    <span id="dd61c765-b18a-4822-b5c6-0d6d1e2c424d">10个最常用</span>
                    <span id="c0d8c540-4ca3-46bc-89ee-152d597e03e0" class="pattern-accent">设计模式</span>
                    <span id="9dc1a0c9-3133-4193-b584-586e62611724">详解</span>
                </h1>
                <p id="27633e18-1c55-4dfc-819f-643a8d715fb5" class="text-xl md:text-2xl text-gray-600 mb-10">优缺点、使用场景与 C++ 实现</p>
                <div id="047bfa4a-65d1-409c-988d-4f4a046ad566" class="flex justify-center gap-4 flex-wrap">
                    <a href="#patterns" id="a1ec6b5e-aad7-41b8-bd89-095a6a24ad40" class="px-8 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-all">
                        开始探索
                    </a>
                    <a href="#guide" id="71e7cbc6-f65c-4ebb-8a8e-723a8ad2bcf1" class="px-8 py-3 bg-white text-blue-600 border border-blue-600 rounded-lg hover:bg-gray-50 transition-all">
                        选择指南
                    </a>
                </div>
            </div>
        </div>
        <div id="5e84e8fa-8a50-46f5-9b75-03d6aad17951" class="absolute top-10 right-10 opacity-10">
            <i class="fas fa-code text-8xl text-blue-600"></i>
        </div>
        <div id="102924c2-ecb3-4253-acce-48afeec456fb" class="absolute bottom-10 left-10 opacity-10">
            <i class="fas fa-layer-group text-8xl text-purple-600"></i>
        </div>
    </section>

    <!-- 简介部分 -->
    <section id="intro" class="py-16 md:py-24 bg-white">
        <div id="53cee4b5-284e-4efc-9248-df8467c34555" class="container mx-auto px-4 md:px-6">
            <div id="7d93c09c-8b2e-4f1a-a407-7e3de4272333" class="animated-element max-w-4xl mx-auto">
                <h2 id="18fb7c02-c5c2-4fd4-9eda-bb032566c3f3" class="text-3xl md:text-4xl font-bold mb-8 text-center">
                    <span id="b12e75b2-749e-4c51-a13c-1d1f2a7049d3" class="pattern-accent">什么是设计模式？</span>
                </h2>
                <div id="56ad7c7f-b01c-41c8-abca-8d9a69e83025" class="mb-12">
                    <p id="0e127070-40cb-4d37-bb8d-1f0a3a3262bf" class="text-lg text-gray-700 mb-6">
                        设计模式是软件设计中常见问题的经典解决方案。它们是经过实践检验的代码设计经验，是解决特定场景问题的模板，不是具体的代码，而是用于设计软件的准则和范式。
                    </p>
                    <p id="96923ab0-0c3e-454c-ba4c-2f12829510dd" class="text-lg text-gray-700 mb-6">
                        设计模式最早由"四人帮"（Gang of Four，即 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides）在他们的著作《设计模式：可复用面向对象软件的基础》中提出，该书记录了23种设计模式，成为软件工程的里程碑。
                    </p>
                </div>
                
                <div id="6f120400-ecb8-4936-84da-9d3d283289f7" class="grid grid-cols-1 md:grid-cols-3 gap-8 mb-12">
                    <div id="eabfa700-9421-4fbf-9b25-4ab87e4de47d" class="card p-6 animated-element">
                        <div id="02e204f7-b0c5-4e64-992b-a521e46d4e08" class="flex items-center mb-4">
                            <div id="ed702320-2656-418c-b91e-da9948c83a21" class="w-12 h-12 rounded-full primary-gradient flex items-center justify-center">
                                <i class="fas fa-recycle text-white text-xl"></i>
                            </div>
                            <h3 id="6d615d1e-8b13-4195-9da9-2793af7038c8" class="ml-4 text-xl font-bold">可复用性</h3>
                        </div>
                        <p id="3c9491ef-a50e-4299-aafe-fdd54af506c4" class="text-gray-600">
                            设计模式提供了经过测试的开发范式，帮助你避免重复发明轮子，提高代码可复用性和可维护性。
                        </p>
                    </div>
                    
                    <div id="82868402-df62-4ac2-8bea-712cd728c9a2" class="card p-6 animated-element">
                        <div id="c5e56ba9-c960-46e8-9dcd-6d1417815334" class="flex items-center mb-4">
                            <div id="5c09036e-0297-41c1-9260-bf8f487e920d" class="w-12 h-12 rounded-full secondary-gradient flex items-center justify-center">
                                <i class="fas fa-comments text-white text-xl"></i>
                            </div>
                            <h3 id="aa22d0c0-da26-47a0-b300-c87324188bea" class="ml-4 text-xl font-bold">通用语言</h3>
                        </div>
                        <p id="7400b330-d49a-47ed-bd2d-3dfa247a0c69" class="text-gray-600">
                            设计模式为开发团队提供共通的词汇和沟通基础，使架构和设计讨论更加清晰高效。
                        </p>
                    </div>
                    
                    <div id="e8024272-1ae5-4578-952f-bbfdd13e27e7" class="card p-6 animated-element">
                        <div id="67ccbaa8-8354-4e79-ba0e-9e24f9b7bdf3" class="flex items-center mb-4">
                            <div id="82887c64-a8a1-4ac2-ac89-934e090379c0" class="w-12 h-12 rounded-full accent-gradient flex items-center justify-center">
                                <i class="fas fa-lightbulb text-white text-xl"></i>
                            </div>
                            <h3 id="5f2fcb52-7661-4349-8d25-6176141fa0cd" class="ml-4 text-xl font-bold">最佳实践</h3>
                        </div>
                        <p id="3de70eae-1c8f-4c22-a5ba-7fe5f62423cb" class="text-gray-600">
                            设计模式代表了专业软件开发的最佳实践，可以帮助你编写更加健壮、灵活和可维护的代码。
                        </p>
                    </div>
                </div>

                <div id="218ec511-b435-4b3c-b8d9-77f09319da40" class="chart-container animated-element">
                    <div id="patterns-categories-chart" style="width: 100%; height: 400px;"></div>
                </div>
            </div>
        </div>
    </section>

    <!-- 目录导航 -->
    <section id="table-of-contents" class="py-12 bg-gray-50">
        <div id="5b10b617-c96c-45b3-8129-e3ccc742afb6" class="container mx-auto px-4 md:px-6">
            <h2 id="e7f5c9aa-9a5b-43d4-847a-b45b46cb0c0c" class="text-3xl font-bold mb-8 text-center">
                <span id="0c105459-0e68-4522-b902-eda6861bd499">目录</span>
                <span id="b2b3a332-0c38-4fdd-b3eb-76f19e7c25dd" class="pattern-accent"> Navigation</span>
            </h2>
            
            <div id="079edb8a-9aff-48be-81b0-610c3e70fa30" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-5 gap-4 animated-element">
                <a href="#singleton" id="20691916-ea0b-47d8-ad67-27a02c03ac03" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="c9a0c0d3-5654-46fb-a52a-4a6f97657348" class="text-4xl font-black text-blue-500">01</span>
                    <span id="e0f26ee9-1fe3-44fd-90c2-e7653d22e3a9" class="font-bold">单例模式</span>
                    <span id="3ff93b89-3d17-41e5-b67a-2cb600e6002c" class="text-sm text-gray-500">Singleton Pattern</span>
                </a>
                <a href="#factory" id="8a5e49f3-4831-4756-a9d6-549c9ae53b72" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="4d323673-469d-4699-bf5e-cff14af0c29d" class="text-4xl font-black text-blue-500">02</span>
                    <span id="505fb502-2ce5-45f3-a205-d9989fbe510c" class="font-bold">工厂方法模式</span>
                    <span id="bbc9c698-329d-46f1-ae5a-e41dc6a9a531" class="text-sm text-gray-500">Factory Method Pattern</span>
                </a>
                <a href="#observer" id="7550fec0-0218-44b8-a20d-6bd8da862a67" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="5928ef47-cea1-4255-a909-f5e879c841d8" class="text-4xl font-black text-blue-500">03</span>
                    <span id="3e38fd28-cf97-4c37-b017-d2a4d44435f7" class="font-bold">观察者模式</span>
                    <span id="b041be9e-00f7-4f3d-9c55-de16e598e1fc" class="text-sm text-gray-500">Observer Pattern</span>
                </a>
                <a href="#strategy" id="6cb53150-316a-41ce-8301-738679c9049e" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="187f81e0-bd22-48bb-b492-99fe0d3bd9aa" class="text-4xl font-black text-blue-500">04</span>
                    <span id="544b8898-4286-4558-8936-ffb21a7d7f25" class="font-bold">策略模式</span>
                    <span id="17bada18-9759-4b4b-966e-dd8e38c9631b" class="text-sm text-gray-500">Strategy Pattern</span>
                </a>
                <a href="#decorator" id="4e557dd9-fcc5-49ff-922c-7415462a0611" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="c8deb247-826c-4b78-ae29-ad327e71dc53" class="text-4xl font-black text-blue-500">05</span>
                    <span id="8b9c5f8b-6128-44bf-b03a-64acf0307009" class="font-bold">装饰器模式</span>
                    <span id="35b2b7e1-469c-43a5-a428-3c79dd6c5de0" class="text-sm text-gray-500">Decorator Pattern</span>
                </a>
                <a href="#adapter" id="f56f1189-277c-4014-8a93-4062e1d1a4a8" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="674bef87-ef82-444b-9349-562456c536f6" class="text-4xl font-black text-purple-500">06</span>
                    <span id="b5978ce6-1ce7-4c60-8a0d-f45b287e544b" class="font-bold">适配器模式</span>
                    <span id="78e8e296-750f-4910-932d-58670464e947" class="text-sm text-gray-500">Adapter Pattern</span>
                </a>
                <a href="#command" id="b71c3534-041e-4eee-aa3e-5f0c57ce52fc" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="2abb97e5-b453-4526-b3d1-2afdf431bd49" class="text-4xl font-black text-purple-500">07</span>
                    <span id="6d5943fa-f793-4f5d-abc5-6442d923a5d3" class="font-bold">命令模式</span>
                    <span id="e09783ce-8dc0-4e27-b382-8ff1dedb9cf6" class="text-sm text-gray-500">Command Pattern</span>
                </a>
                <a href="#proxy" id="e8df40e3-52f5-4e55-a39e-e411455d71ff" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="f1212263-ff38-4023-80a5-5e628a4cb4db" class="text-4xl font-black text-purple-500">08</span>
                    <span id="38579c83-8e76-4cbe-9339-c087bc70e6f3" class="font-bold">代理模式</span>
                    <span id="20a0b8ca-3779-4d22-a607-4b756ec52d84" class="text-sm text-gray-500">Proxy Pattern</span>
                </a>
                <a href="#template" id="405e3742-391d-480c-b7b0-2674f74f7357" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="29d0c967-9535-46f1-8563-7ec631f9f19a" class="text-4xl font-black text-purple-500">09</span>
                    <span id="d7f516e6-eac4-4388-834b-4e6cd13eb087" class="font-bold">模板方法模式</span>
                    <span id="3b47c528-9825-4f19-a225-db2fd1e1d3e2" class="text-sm text-gray-500">Template Method Pattern</span>
                </a>
                <a href="#composite" id="323dc9cc-a7e9-4a06-8c52-5cf0aab28c34" class="card p-4 hover:bg-blue-50 transition-all flex flex-col items-center">
                    <span id="9b14fcf2-1041-4b17-a9b4-c8d797bf9ef8" class="text-4xl font-black text-purple-500">10</span>
                    <span id="fec709fa-722f-46e1-8fba-44ec8c04582d" class="font-bold">组合模式</span>
                    <span id="8aa93101-9cd7-40e2-9a9c-04c2a43e85eb" class="text-sm text-gray-500">Composite Pattern</span>
                </a>
            </div>
        </div>
    </section>

    <!-- 设计模式详解 -->
    <section id="patterns" class="py-16">
        <div id="968fe99a-489d-4f13-9bd9-28448b92a8f6" class="container mx-auto px-4 md:px-6">
            <h2 id="980e0238-2774-402b-89d0-ee45cd472ce9" class="text-4xl font-bold mb-20 text-center animated-element">
                <span id="d4ceada0-aecc-4ace-88da-07b7411e24d2" class="pattern-accent">设计模式</span>
                <span id="71c6a0e5-8e74-4308-8e14-e80812743230"> 详解</span>
                <span id="4246d41b-1d4d-43ee-8af9-64effc9f1729" class="text-gray-400 block text-xl mt-2">Design Pattern Details</span>
            </h2>

            <!-- 单例模式 -->
            <div id="singleton" class="mb-32">
                <div id="442752f1-4c8c-4372-a950-48eb97fc63a8" class="relative mb-12">
                    <div id="29c0f612-4981-48a0-a99d-709c03dcc0de" class="animated-element">
                        <span id="4dd51397-46cb-428a-965f-0f25e9efdace" class="number-accent text-blue-500">01</span>
                        <h3 id="417bef0f-167a-4fe0-85fe-f5a52026bcd7" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">单例模式</h3>
                        <p id="72d62802-ad8d-4dee-a804-833c44159deb" class="text-xl text-gray-600 mb-6">Singleton Pattern</p>
                        <p id="d92a99ad-0c6c-4ce6-8729-0b3bb0340d58" class="text-lg text-gray-700 mb-8">
                            确保一个类只有一个实例，并提供一个全局访问点来访问这个实例。单例模式是最简单但也是使用最广泛的设计模式之一。
                        </p>
                    </div>

                    <div id="e536cc3a-e191-42d5-90c1-247ff47e5225" class="chart-container animated-element">
                        <div id="singleton-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="5df56072-3676-4308-8fea-dd7a037ab6bb" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="d8f63e7d-348e-4a75-b694-2ef4bbd62799" class="animated-element">
                            <h4 id="422a115a-7b52-4e5c-a4cf-cfcaf643f39a" class="text-xl font-bold mb-4 flex items-center">
                                <span id="ae6e92e0-060c-4e78-b7e6-fd54816c8901" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="bb81f50b-4966-4dbb-bff5-f551d01bf6eb" class="benefits-list">
                                <li id="51f60c15-3c3a-4681-82d3-f229045633d9"><i class="fas fa-check-circle"></i> 保证一个类只有一个实例，避免资源冲突</li>
                                <li id="350251bc-e340-42b2-8458-3f9e5aa6fbad"><i class="fas fa-check-circle"></i> 全局访问点，方便控制对实例的访问方式</li>
                                <li id="443880b2-c12e-4403-a70d-0762a9534e1b"><i class="fas fa-check-circle"></i> 延迟初始化实例，减少不必要的资源开销</li>
                            </ul>
                        </div>
                        
                        <div id="c79fd698-ecc7-4baa-8051-62e86ded7aaf" class="animated-element">
                            <h4 id="7f0fd4b8-ac1f-4690-b83e-9335aa9ccdbe" class="text-xl font-bold mb-4 flex items-center">
                                <span id="96d886c0-2bbc-4cac-be32-6116269d9e5d" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="55aa5284-4623-4757-8206-7cbc8307fdef" class="drawbacks-list">
                                <li id="e4eea6da-3e74-4a42-a2cb-86d77178fe06"><i class="fas fa-times-circle"></i> 在多线程环境中实现复杂</li>
                                <li id="cfd53143-4349-4198-a4bc-ce32372714a3"><i class="fas fa-times-circle"></i> 违反单一职责原则</li>
                                <li id="7c0ddd3f-3d4f-4c10-a1d5-8d3831c235f7"><i class="fas fa-times-circle"></i> 难以进行单元测试</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="d022609f-6dd1-4df0-8aa8-08e93269291c" class="mb-10 animated-element">
                        <h4 id="73ce2d12-0445-4f47-bdfc-8a24786b638b" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="0ef5b8cd-9742-4c8c-b09a-a557b39fa77e" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="6fc24254-66b7-4fae-9716-53e97cd8631f">需要频繁创建和销毁的对象，如数据库连接池</li>
                            <li id="77cce4d3-843d-434b-b1dd-19234246dd8e">多个组件需要共享资源，如配置信息、线程池或缓存</li>
                            <li id="c3bae2fa-74d0-4fa7-b992-9d31945f17af">当需要控制资源的并发访问时</li>
                        </ul>
                    </div>
                    
                    <div id="50d20b88-7cd8-4c8c-827c-7e4bb9781b83" class="animated-element">
                        <h4 id="5d9b313c-d8d7-454e-acfa-069595e1017d" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="c0e839a5-c3af-4039-916d-ba13f6170358" class="code-block">
<pre><code class="language-cpp">// 线程安全的懒汉式单例模式
class Singleton {
private:
    // 私有构造函数
    Singleton() {
        std::cout &lt;&lt; "单例被创建" &lt;&lt; std::endl;
    }
    
    // 禁止复制和赋值
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
    
    // 静态实例指针
    static std::unique_ptr&lt;Singleton&gt; instance_;
    static std::mutex mutex_;

public:
    // 析构函数
    ~Singleton() {
        std::cout &lt;&lt; "单例被销毁" &lt;&lt; std::endl;
    }
    
    // 获取单例实例的全局访问点
    static Singleton& getInstance() {
        // 双重检查锁定
        if (instance_ == nullptr) {
            std::lock_guard&lt;std::mutex&gt; lock(mutex_);
            if (instance_ == nullptr) {
                instance_.reset(new Singleton());
            }
        }
        return *instance_;
    }
    
    // 业务方法示例
    void doSomething() {
        std::cout &lt;&lt; "单例执行某项任务" &lt;&lt; std::endl;
    }
};

// 静态成员初始化
std::unique_ptr&lt;Singleton&gt; Singleton::instance_ = nullptr;
std::mutex Singleton::mutex_;

// 使用示例
int main() {
    // 获取单例实例
    Singleton& s1 = Singleton::getInstance();
    s1.doSomething();
    
    // 再次获取实例（实际上是同一个实例）
    Singleton& s2 = Singleton::getInstance();
    
    // 验证是否是同一实例
    std::cout &lt;&lt; "s1和s2是否是同一个实例: " 
              &lt;&lt; (&s1 == &s2 ? "是" : "否") &lt;&lt; std::endl;
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 工厂方法模式 -->
            <div id="factory" class="mb-32">
                <div id="392fa8c8-396e-4d04-8b84-a4c264c91bb3" class="relative mb-12">
                    <div id="a8203376-c08f-44bf-8c8c-f7a657170fc0" class="animated-element">
                        <span id="6a95d0c0-5f73-4382-bb61-249048ab7e55" class="number-accent text-blue-500">02</span>
                        <h3 id="fe3f457d-e18c-4369-80f2-855de952047b" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">工厂方法模式</h3>
                        <p id="4a283851-4bf5-4074-9064-d81d7ae3500d" class="text-xl text-gray-600 mb-6">Factory Method Pattern</p>
                        <p id="0630d532-3697-445f-877a-5b336a28d17a" class="text-lg text-gray-700 mb-8">
                            定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。这种模式处理对象的创建，同时不暴露创建逻辑。
                        </p>
                    </div>
                    
                    <div id="9251089a-7c53-4007-908b-f65fd087917b" class="chart-container animated-element">
                        <div id="factory-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="04669c50-99eb-4e32-a2b1-3a68d4ccd41e" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="5275c92a-c2b0-48d3-8d64-3d5f8ff97010" class="animated-element">
                            <h4 id="89460928-45b1-4756-b9dc-987b1a11ca3c" class="text-xl font-bold mb-4 flex items-center">
                                <span id="96167bcd-8c31-423a-9f70-5a6c77032ebe" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="c790cb63-c00f-464c-bd7c-9d90b8a4c134" class="benefits-list">
                                <li id="9d04d115-04d7-4a7b-b504-7b87abacf292"><i class="fas fa-check-circle"></i> 遵循开闭原则，便于扩展</li>
                                <li id="1913e712-fbe5-438c-a969-e9e6f89e739c"><i class="fas fa-check-circle"></i> 将创建与业务逻辑分离，降低耦合性</li>
                                <li id="e8e04d5e-3967-4275-a6ac-8643ea187b38"><i class="fas fa-check-circle"></i> 客户端代码与具体产品解耦</li>
                            </ul>
                        </div>
                        
                        <div id="ceb69b3d-5b24-40c2-9bce-1bb0765c0b3e" class="animated-element">
                            <h4 id="048ff866-579b-4aa0-9c14-1755b1c9a099" class="text-xl font-bold mb-4 flex items-center">
                                <span id="e23092b3-df77-4c6e-8639-de64b503cdfe" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="d1b2a5cd-73ce-4302-b9d4-ed8d63ce1fb0" class="drawbacks-list">
                                <li id="0456b303-7fcc-452a-b3ec-aadb1d9c9972"><i class="fas fa-times-circle"></i> 增加新产品时需要编写新的具体工厂类和产品类</li>
                                <li id="9ef59412-a555-4472-bffc-020681c3fc77"><i class="fas fa-times-circle"></i> 代码结构较为复杂</li>
                                <li id="378ddb58-9ad2-434e-888a-74f9b2b90ca5"><i class="fas fa-times-circle"></i> 客户端必须了解不同工厂对应不同产品</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="46535073-1436-4783-a17a-69a68e46abfb" class="mb-10 animated-element">
                        <h4 id="5951dc8a-f253-49a9-b40e-8fae70bf54e1" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="f3784716-aae0-4f10-ad1c-d6c2e0eb5eda" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="a0c75e50-89ef-4d1b-b9ba-dada9d1c3327">当无法预知要创建对象的确切类型时</li>
                            <li id="82a9026e-0204-46f1-ba6b-6bb209377199">当一个类希望由其子类来指定创建对象时</li>
                            <li id="6aebfea5-7a4a-409e-bbd5-daef8fbfe953">用于框架和库，允许用户扩展系统的内部对象</li>
                        </ul>
                    </div>
                    
                    <div id="e539448b-cfbf-4964-8f22-6af87d908b99" class="animated-element">
                        <h4 id="1a4da1c4-0513-4b12-bc36-59a227d930b3" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="c459c620-54b4-499e-b116-1f78a3b58446" class="code-block">
<pre><code class="language-cpp">// 产品抽象类
class Product {
public:
    virtual ~Product() {}
    virtual std::string operation() const = 0;
};

// 具体产品A
class ConcreteProductA : public Product {
public:
    std::string operation() const override {
        return "这是产品A的结果";
    }
};

// 具体产品B
class ConcreteProductB : public Product {
public:
    std::string operation() const override {
        return "这是产品B的结果";
    }
};

// 工厂抽象类
class Creator {
public:
    virtual ~Creator() {}
    
    // 工厂方法
    virtual std::unique_ptr&lt;Product&gt; createProduct() const = 0;
    
    // 使用工厂方法的基础业务逻辑
    std::string someOperation() const {
        // 调用工厂方法创建产品
        std::unique_ptr&lt;Product&gt; product = this->createProduct();
        
        // 使用产品
        return "创建者: " + product->operation();
    }
};

// 具体工厂A，创建产品A
class ConcreteCreatorA : public Creator {
public:
    std::unique_ptr&lt;Product&gt; createProduct() const override {
        return std::make_unique&lt;ConcreteProductA&gt;();
    }
};

// 具体工厂B，创建产品B
class ConcreteCreatorB : public Creator {
public:
    std::unique_ptr&lt;Product&gt; createProduct() const override {
        return std::make_unique&lt;ConcreteProductB&gt;();
    }
};

// 客户端代码
void clientCode(const Creator& creator) {
    std::cout &lt;&lt; "客户端代码使用工厂: " &lt;&lt; creator.someOperation() &lt;&lt; std::endl;
}

int main() {
    std::cout &lt;&lt; "使用具体创建者A:" &lt;&lt; std::endl;
    ConcreteCreatorA creatorA;
    clientCode(creatorA);
    
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "使用具体创建者B:" &lt;&lt; std::endl;
    ConcreteCreatorB creatorB;
    clientCode(creatorB);
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 观察者模式 -->
            <div id="observer" class="mb-32">
                <div id="b32a1c56-3457-4ac7-87b0-17024a480d62" class="relative mb-12">
                    <div id="018559b5-9924-4958-a89c-942c62202cf9" class="animated-element">
                        <span id="136306f7-0c3b-4971-bc87-a61346f8cc7b" class="number-accent text-blue-500">03</span>
                        <h3 id="3688bd73-4a5a-4d78-a012-f1a97bb6332d" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">观察者模式</h3>
                        <p id="7a2bcad7-1243-46e5-9ed2-181c4db1bd3b" class="text-xl text-gray-600 mb-6">Observer Pattern</p>
                        <p id="a87411ba-ebfc-4b41-bf21-8fffe188ab63" class="text-lg text-gray-700 mb-8">
                            定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式常用于实现分布式事件处理系统。
                        </p>
                    </div>
                    
                    <div id="750d282e-c334-47e0-bbdb-36c78768c5e8" class="chart-container animated-element">
                        <div id="observer-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="54c98ca6-f11e-4b0e-9982-d3e0bb77dede" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="4d7af254-f203-44b9-b3df-382729132be3" class="animated-element">
                            <h4 id="c4a94178-0c85-4f5f-ae5c-3dec1582d6c0" class="text-xl font-bold mb-4 flex items-center">
                                <span id="c45c9414-22bc-4cfa-831e-27ed38a5df2d" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="2bcac678-2d87-4272-b605-75036721bedb" class="benefits-list">
                                <li id="484736d3-6f82-4075-98f3-11bcded115c8"><i class="fas fa-check-circle"></i> 支持对象间松耦合设计</li>
                                <li id="65077882-6c0c-4181-8df4-388cbd72cea9"><i class="fas fa-check-circle"></i> 遵循开闭原则，方便添加新观察者</li>
                                <li id="bb3f6198-e208-486b-a74c-e91f1db11507"><i class="fas fa-check-circle"></i> 支持广播通信和一对多通知</li>
                            </ul>
                        </div>
                        
                        <div id="a373850a-0b08-47a6-b17a-3b726fe3ceea" class="animated-element">
                            <h4 id="5d438a7a-ff0e-48ab-8b7e-f7545a0f928a" class="text-xl font-bold mb-4 flex items-center">
                                <span id="a7652e28-c137-4812-ac94-9a486bb5098e" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="a0a0937d-dd4c-45a9-961c-6e1e7469906a" class="drawbacks-list">
                                <li id="290c87b5-3b4a-4bf8-970c-f77b05c7c6e9"><i class="fas fa-times-circle"></i> 观察者过多可能导致性能问题</li>
                                <li id="df6d4eed-71bb-40d8-b441-8d9a894c7fac"><i class="fas fa-times-circle"></i> 可能导致循环通知和意外的副作用</li>
                                <li id="05e24c32-b6bb-46ba-a3ee-8416bf8fca88"><i class="fas fa-times-circle"></i> 通知顺序不可控，可能导致复杂度提高</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="e65ab43e-72ee-4695-9a73-877266bb1c81" class="mb-10 animated-element">
                        <h4 id="800a5a48-8189-45e8-bb37-c0619b2b9edd" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="9d2ec24a-6f85-43d5-8a1f-d414af157564" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="31110e79-8981-4afd-82ac-c8d35dc10d2a">当一个对象状态改变需要通知其他对象，但不知道这些对象具体是谁</li>
                            <li id="713427d0-e054-4fb0-a9c1-77448ef2515f">事件驱动系统和GUI开发（如按钮点击事件处理）</li>
                            <li id="06577cb5-e60e-4fa7-8e2b-dc81d919d3b6">实时消息通知，如邮件、消息订阅和日志系统</li>
                        </ul>
                    </div>
                    
                    <div id="8f504c54-372c-4afc-ad02-ece3ad4e7f41" class="animated-element">
                        <h4 id="c57dc64c-618b-4dbc-a49e-c5e1e371b7fb" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="388acb28-8b45-45ec-ae91-e369287f4b54" class="code-block">
<pre><code class="language-cpp">// 观察者抽象类
class Observer {
public:
    virtual ~Observer() = default;
    virtual void update(const std::string& message) = 0;
};

// 主题/被观察者抽象类
class Subject {
public:
    virtual ~Subject() = default;
    virtual void attach(Observer* observer) = 0;
    virtual void detach(Observer* observer) = 0;
    virtual void notify() = 0;
};

// 具体主题
class ConcreteSubject : public Subject {
private:
    std::list&lt;Observer*&gt; observers_;
    std::string message_;

public:
    void attach(Observer* observer) override {
        observers_.push_back(observer);
    }

    void detach(Observer* observer) override {
        observers_.remove(observer);
    }

    void notify() override {
        for (Observer* observer : observers_) {
            observer->update(message_);
        }
    }

    // 设置状态并通知所有观察者
    void createMessage(const std::string& message) {
        message_ = message;
        notify();
    }

    void someBusinessLogic() {
        message_ = "状态已更改";
        notify();
        std::cout &lt;&lt; "我执行了一些重要的业务逻辑\n";
    }
};

// 具体观察者A
class ConcreteObserverA : public Observer {
private:
    std::string name_;

public:
    explicit ConcreteObserverA(const std::string& name) : name_(name) {}

    void update(const std::string& message) override {
        std::cout &lt;&lt; name_ &lt;&lt; " 收到通知: " &lt;&lt; message &lt;&lt; std::endl;
    }
};

// 具体观察者B
class ConcreteObserverB : public Observer {
private:
    std::string name_;

public:
    explicit ConcreteObserverB(const std::string& name) : name_(name) {}

    void update(const std::string& message) override {
        std::cout &lt;&lt; name_ &lt;&lt; " 收到更新: " &lt;&lt; message &lt;&lt; std::endl;
        // 具体观察者B对通知有特殊处理
        std::cout &lt;&lt; name_ &lt;&lt; " 执行特殊反应\n";
    }
};

// 客户端代码
int main() {
    ConcreteSubject subject;

    ConcreteObserverA observerA("观察者A");
    ConcreteObserverB observerB("观察者B");
    
    subject.attach(&observerA);
    subject.attach(&observerB);
    
    subject.createMessage("重要通知: 新事件发生!");
    
    subject.detach(&observerB);
    
    std::cout &lt;&lt; "\n观察者B已移除\n\n";
    
    subject.createMessage("第二条通知: 状态更新!");
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 策略模式 -->
            <div id="strategy" class="mb-32">
                <div id="22c2ee8b-f953-4cf0-94dd-907a5f8d5d0b" class="relative mb-12">
                    <div id="78db162c-905c-4c8f-8a6c-d7a9bdad5879" class="animated-element">
                        <span id="56b5ee6e-3799-443d-9fd3-db652e47872e" class="number-accent text-blue-500">04</span>
                        <h3 id="28ae5f93-d878-4343-bdc1-3c5bd4e7384b" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">策略模式</h3>
                        <p id="47777df0-41fe-422b-8e3e-7c7ff74708a3" class="text-xl text-gray-600 mb-6">Strategy Pattern</p>
                        <p id="ed16310a-7b12-44f3-b8df-7927a563e53e" class="text-lg text-gray-700 mb-8">
                            定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。策略模式让算法独立于使用它的客户而变化，支持不同行为的动态切换。
                        </p>
                    </div>
                    
                    <div id="b474f5f5-86c1-4f5a-9d1c-339c894c3d58" class="chart-container animated-element">
                        <div id="strategy-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="ae41bd10-0cce-415d-8afb-fd08f6972324" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="adc28871-7807-46a3-adde-e6a00a8d51cc" class="animated-element">
                            <h4 id="187d6ed0-ee58-4411-ad4c-4b88746ce503" class="text-xl font-bold mb-4 flex items-center">
                                <span id="e9af38fb-b7f0-40c7-94c6-989be1e05f9a" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="4d1ba1fa-bc7e-4fc9-a705-f77aaa2731d5" class="benefits-list">
                                <li id="77d3ac5a-1deb-421d-bad7-c6d88ac52bef"><i class="fas fa-check-circle"></i> 支持算法的动态切换</li>
                                <li id="6fc3674a-c0c3-4024-925e-ecbc538b95be"><i class="fas fa-check-circle"></i> 避免使用多重条件判断</li>
                                <li id="9fa30819-551c-4817-a936-9481bc9a9bf2"><i class="fas fa-check-circle"></i> 将算法实现和使用分离，易于扩展</li>
                            </ul>
                        </div>
                        
                        <div id="fbe4239a-055e-4119-b59e-5d0ab6332433" class="animated-element">
                            <h4 id="904d6566-c032-4f11-96ea-797dd0f7c78f" class="text-xl font-bold mb-4 flex items-center">
                                <span id="275f711e-ee70-40f2-b838-0f8b4c3abecc" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="50211e29-fe76-4317-bb70-cc90db63c102" class="drawbacks-list">
                                <li id="1230bb91-15ac-46c3-a001-ee663187b6e0"><i class="fas fa-times-circle"></i> 客户端必须了解所有的策略类</li>
                                <li id="5abe7e56-11ca-4806-83e5-fe7632ad7b36"><i class="fas fa-times-circle"></i> 策略类数量可能增多</li>
                                <li id="0f6d783a-f516-405b-86b9-0c7fd8e3d267"><i class="fas fa-times-circle"></i> 增加了对象的数量</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="cc887255-b510-4c4d-bc10-f0dcea8a2f15" class="mb-10 animated-element">
                        <h4 id="814a49d8-46b1-4c2f-8f6d-1d9c7249666e" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="0c59fa6f-2c53-40aa-a535-7e38bc67c43c" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="ff962b34-3c7c-48f6-866a-3e91166d6d65">需要在运行时选择算法的场景，如排序算法</li>
                            <li id="82568398-4530-4576-a17c-29ba1d022ebf">避免使用多重条件语句处理不同的行为</li>
                            <li id="fbbb4fa3-25e8-48e6-b245-c9281704ac67">有一系列可互换的算法，如压缩算法、验证策略或支付方式</li>
                        </ul>
                    </div>
                    
                    <div id="5624cdcc-a0cf-45bf-a3ed-f32909b29484" class="animated-element">
                        <h4 id="42e89c1e-2ab2-46f0-b990-cb40994a9952" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="9163571e-a6dc-4c03-96ab-ca22fb457423" class="code-block">
<pre><code class="language-cpp">// 策略接口
class PaymentStrategy {
public:
    virtual ~PaymentStrategy() = default;
    virtual bool pay(double amount) = 0;
    virtual std::string getName() const = 0;
};

// 具体策略 - 信用卡支付
class CreditCardPayment : public PaymentStrategy {
private:
    std::string name_;
    std::string cardNumber_;
    std::string cvv_;
    std::string dateOfExpiry_;
    
public:
    CreditCardPayment(const std::string& name, 
                     const std::string& cardNumber, 
                     const std::string& cvv, 
                     const std::string& expiryDate)
        : name_(name), cardNumber_(cardNumber), cvv_(cvv), dateOfExpiry_(expiryDate) {}
        
    bool pay(double amount) override {
        std::cout &lt;&lt; amount &lt;&lt; "元已通过信用卡支付\n";
        return true;
    }
    
    std::string getName() const override {
        return "信用卡支付";
    }
};

// 具体策略 - 支付宝支付
class AlipayPayment : public PaymentStrategy {
private:
    std::string emailId_;
    std::string password_;
    
public:
    AlipayPayment(const std::string& email, const std::string& pwd)
        : emailId_(email), password_(pwd) {}
        
    bool pay(double amount) override {
        std::cout &lt;&lt; amount &lt;&lt; "元已通过支付宝支付\n";
        return true;
    }
    
    std::string getName() const override {
        return "支付宝支付";
    }
};

// 具体策略 - 微信支付
class WeChatPayment : public PaymentStrategy {
private:
    std::string id_;
    
public:
    explicit WeChatPayment(const std::string& id) : id_(id) {}
    
    bool pay(double amount) override {
        std::cout &lt;&lt; amount &lt;&lt; "元已通过微信支付\n";
        return true;
    }
    
    std::string getName() const override {
        return "微信支付";
    }
};

// 上下文类
class ShoppingCart {
private:
    std::vector&lt;double&gt; prices_;
    PaymentStrategy* paymentStrategy_;

public:
    ShoppingCart() : paymentStrategy_(nullptr) {}
    
    void addItem(double price) {
        prices_.push_back(price);
    }
    
    double calculateTotal() const {
        double sum = 0;
        for (double price : prices_) {
            sum += price;
        }
        return sum;
    }
    
    void setPaymentStrategy(PaymentStrategy* strategy) {
        paymentStrategy_ = strategy;
    }
    
    bool checkout() {
        if (!paymentStrategy_) {
            std::cout &lt;&lt; "请先设置支付方式!\n";
            return false;
        }
        
        double amount = calculateTotal();
        std::cout &lt;&lt; "购物车总金额: " &lt;&lt; amount 
                 &lt;&lt; "元, 使用" &lt;&lt; paymentStrategy_->getName() 
                 &lt;&lt; "支付\n";
                 
        return paymentStrategy_->pay(amount);
    }
};

// 客户端代码
int main() {
    ShoppingCart cart;
    
    cart.addItem(100);
    cart.addItem(50);
    cart.addItem(200);
    
    std::cout &lt;&lt; "总金额: " &lt;&lt; cart.calculateTotal() &lt;&lt; "元\n\n";
    
    // 使用信用卡支付
    CreditCardPayment creditCard("张三", "1234 5678 9012 3456", "123", "12/25");
    cart.setPaymentStrategy(&creditCard);
    cart.checkout();
    
    std::cout &lt;&lt; "\n更换支付方式\n\n";
    
    // 使用支付宝支付
    AlipayPayment alipay("example@mail.com", "password");
    cart.setPaymentStrategy(&alipay);
    cart.checkout();
    
    std::cout &lt;&lt; "\n更换支付方式\n\n";
    
    // 使用微信支付
    WeChatPayment wechat("wx123456");
    cart.setPaymentStrategy(&wechat);
    cart.checkout();
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 装饰器模式 -->
            <div id="decorator" class="mb-32">
                <div id="cf89fb43-74df-4eef-b981-f689ae9034ad" class="relative mb-12">
                    <div id="a302adad-a6b2-40a7-a808-9d040d081e8b" class="animated-element">
                        <span id="4993f754-d4bc-4c6d-bfa0-418a20845c81" class="number-accent text-blue-500">05</span>
                        <h3 id="500aed89-4e8e-4d18-bb43-17f36acc439c" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">装饰器模式</h3>
                        <p id="ca534df1-6ad6-4f26-b82a-60ed7af7cc88" class="text-xl text-gray-600 mb-6">Decorator Pattern</p>
                        <p id="eac754fb-687d-4eaa-9aed-b7f1d2226f48" class="text-lg text-gray-700 mb-8">
                            动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更为灵活。在不修改原对象代码的情况下，能够为对象动态添加功能。
                        </p>
                    </div>
                    
                    <div id="5078d601-9ca2-4d76-bf66-979910b6cc5d" class="chart-container animated-element">
                        <div id="decorator-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="7a6361c6-3a06-442d-875a-d3568d71b5e8" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="a9d4ba5a-1352-48dc-be6c-3208119b22a2" class="animated-element">
                            <h4 id="be563f3f-cb38-4fb8-91e3-d40f91ecdd1c" class="text-xl font-bold mb-4 flex items-center">
                                <span id="81cf9b1b-38cd-464c-8385-e892b7f54c9e" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="d6f6418e-e823-4530-a782-10cea25e58cd" class="benefits-list">
                                <li id="bb31947f-c1bf-4230-ae3a-d9a41e9560e9"><i class="fas fa-check-circle"></i> 比继承更灵活，可以动态地增强功能</li>
                                <li id="f93b07d6-8665-476f-9bee-43949759ac6d"><i class="fas fa-check-circle"></i> 遵循开闭原则，易于维护和扩展</li>
                                <li id="f82fef7e-fa01-4509-a28a-d69f4120effe"><i class="fas fa-check-circle"></i> 支持功能的排列组合，可以任意组合功能</li>
                            </ul>
                        </div>
                        
                        <div id="ded4eec9-12b4-4371-b1d4-eca33daa9709" class="animated-element">
                            <h4 id="ce58c16c-a962-4ba2-b031-d8f87010c741" class="text-xl font-bold mb-4 flex items-center">
                                <span id="7b1b4b87-0e4b-4dca-b9bd-2aa4b6767ab1" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="f1b0bdca-da1c-4cea-971d-12f53376d57e" class="drawbacks-list">
                                <li id="fc5997cf-28c3-486c-848e-1fd36ef44710"><i class="fas fa-times-circle"></i> 会产生很多小对象，增加系统复杂性</li>
                                <li id="9afe047b-3735-4523-a074-25be6dfbf744"><i class="fas fa-times-circle"></i> 装饰器链可能变得过于复杂</li>
                                <li id="52ec4ff2-4412-47a9-99c3-eaaa91e5076a"><i class="fas fa-times-circle"></i> 难以更改特定装饰器的顺序</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="677c89f9-fda5-48da-9638-67767b8470af" class="mb-10 animated-element">
                        <h4 id="4a65d459-b008-40de-b3ce-37e9d665e633" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="e962076b-114f-456a-84b3-d62976d8828a" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="c388bf57-3628-45b9-b0e0-e9bb97cc372c">在不修改对象代码的前提下动态增强对象功能时</li>
                            <li id="9e61ae14-f147-4424-a11c-aa7fca78fab0">需要组合多种功能，且不希望产生大量子类的情况</li>
                            <li id="7e80e39d-6ec3-43a5-859b-e98fa2e026c0">I/O流处理、UI组件、数据缓冲和日志功能增强等场景</li>
                        </ul>
                    </div>
                    
                    <div id="5a8b48a4-1b50-4af3-b711-fb441ea5327a" class="animated-element">
                        <h4 id="0cd73bb3-ed9f-4267-9eff-da1cdaaa2c51" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="21c26ce4-6af7-443f-9810-b1167c529485" class="code-block">
<pre><code class="language-cpp">// 组件接口
class Coffee {
public:
    virtual ~Coffee() = default;
    virtual double getCost() const = 0;
    virtual std::string getDescription() const = 0;
};

// 具体组件
class SimpleCoffee : public Coffee {
public:
    double getCost() const override {
        return 10.0; // 基础咖啡价格
    }
    
    std::string getDescription() const override {
        return "简单咖啡";
    }
};

// 装饰器基类
class CoffeeDecorator : public Coffee {
protected:
    Coffee* coffee_;
    
public:
    explicit CoffeeDecorator(Coffee* coffee) : coffee_(coffee) {}
    
    virtual ~CoffeeDecorator() {
        delete coffee_;  // 装饰器负责释放被装饰对象
    }
    
    double getCost() const override {
        return coffee_->getCost();
    }
    
    std::string getDescription() const override {
        return coffee_->getDescription();
    }
};

// 具体装饰器 - 牛奶
class MilkDecorator : public CoffeeDecorator {
public:
    explicit MilkDecorator(Coffee* coffee) : CoffeeDecorator(coffee) {}
    
    double getCost() const override {
        return coffee_->getCost() + 2.0; // 牛奶额外加2元
    }
    
    std::string getDescription() const override {
        return coffee_->getDescription() + ", 加牛奶";
    }
};

// 具体装饰器 - 糖
class SugarDecorator : public CoffeeDecorator {
public:
    explicit SugarDecorator(Coffee* coffee) : CoffeeDecorator(coffee) {}
    
    double getCost() const override {
        return coffee_->getCost() + 1.0; // 糖额外加1元
    }
    
    std::string getDescription() const override {
        return coffee_->getDescription() + ", 加糖";
    }
};

// 具体装饰器 - 巧克力
class ChocolateDecorator : public CoffeeDecorator {
public:
    explicit ChocolateDecorator(Coffee* coffee) : CoffeeDecorator(coffee) {}
    
    double getCost() const override {
        return coffee_->getCost() + 5.0; // 巧克力额外加5元
    }
    
    std::string getDescription() const override {
        return coffee_->getDescription() + ", 加巧克力";
    }
};

// 客户端代码
int main() {
    // 制作一杯简单咖啡
    Coffee* simpleCoffee = new SimpleCoffee();
    std::cout &lt;&lt; "饮品: " &lt;&lt; simpleCoffee->getDescription() 
              &lt;&lt; ", 价格: ¥" &lt;&lt; simpleCoffee->getCost() &lt;&lt; std::endl;
    
    // 加牛奶的咖啡
    Coffee* milkCoffee = new MilkDecorator(new SimpleCoffee());
    std::cout &lt;&lt; "饮品: " &lt;&lt; milkCoffee->getDescription() 
              &lt;&lt; ", 价格: ¥" &lt;&lt; milkCoffee->getCost() &lt;&lt; std::endl;
    
    // 加糖和牛奶的咖啡
    Coffee* sweetMilkCoffee = new SugarDecorator(new MilkDecorator(new SimpleCoffee()));
    std::cout &lt;&lt; "饮品: " &lt;&lt; sweetMilkCoffee->getDescription() 
              &lt;&lt; ", 价格: ¥" &lt;&lt; sweetMilkCoffee->getCost() &lt;&lt; std::endl;
    
    // 加巧克力、糖和牛奶的咖啡
    Coffee* deluxeCoffee = new ChocolateDecorator(
                            new SugarDecorator(
                                new MilkDecorator(
                                    new SimpleCoffee())));
    std::cout &lt;&lt; "饮品: " &lt;&lt; deluxeCoffee->getDescription() 
              &lt;&lt; ", 价格: ¥" &lt;&lt; deluxeCoffee->getCost() &lt;&lt; std::endl;
    
    // 别忘了释放内存
    delete simpleCoffee;
    delete milkCoffee;
    delete sweetMilkCoffee;
    delete deluxeCoffee;
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 适配器模式 -->
            <div id="adapter" class="mb-32">
                <div id="703d8d52-f9f0-48f9-80a6-bd15896b89c9" class="relative mb-12">
                    <div id="a78aa43d-58e6-47c8-9b9a-7443c4fde040" class="animated-element">
                        <span id="9a4dac11-8e0f-4c2a-91f4-9a1d13fa5800" class="number-accent text-purple-500">06</span>
                        <h3 id="6c174c1d-cecc-47a5-b3eb-84aa4fa25855" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">适配器模式</h3>
                        <p id="efcf89aa-4ace-475e-ab0f-8b5a641fa6fa" class="text-xl text-gray-600 mb-6">Adapter Pattern</p>
                        <p id="0f4ddb9b-87bc-4cc1-b2df-3fb018115fd5" class="text-lg text-gray-700 mb-8">
                            将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以一起工作。适配器模式实现了代码复用和系统集成。
                        </p>
                    </div>
                    
                    <div id="7b081310-ecb1-490c-b91a-6af75fe02e9f" class="chart-container animated-element">
                        <div id="adapter-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="894d38c5-c2e7-4910-9618-80f57e0937a1" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="a12967b9-f989-426d-93c9-6db918ebca7e" class="animated-element">
                            <h4 id="f0cd7934-58eb-48ce-a689-11a5481e11ed" class="text-xl font-bold mb-4 flex items-center">
                                <span id="532e0a5f-ffbe-4682-9205-7b1edf511c83" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="2bc35d04-6027-43a7-af88-e802672e14ec" class="benefits-list">
                                <li id="8a04a03c-6aca-4458-a75b-6b8fd3aa5910"><i class="fas fa-check-circle"></i> 可以让不兼容的接口一起工作</li>
                                <li id="d1b17c9c-54b2-4d42-be1e-3effe9049431"><i class="fas fa-check-circle"></i> 提高了类的复用性和透明度</li>
                                <li id="b8ba108e-3a9c-4b3e-b9b1-a083c2d9ad88"><i class="fas fa-check-circle"></i> 不需要修改现有代码就能集成新的系统和类库</li>
                            </ul>
                        </div>
                        
                        <div id="0b3cb883-76fe-4917-bbd6-3b0d1f41aedc" class="animated-element">
                            <h4 id="fb82991c-0671-430a-b36d-b6865819e652" class="text-xl font-bold mb-4 flex items-center">
                                <span id="910df396-9fb0-472b-95a3-7daee551f986" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="caa60b12-ba31-4967-ab36-d41b37002bba" class="drawbacks-list">
                                <li id="8bd2f091-54d1-4674-a01d-bc504fab26c6"><i class="fas fa-times-circle"></i> 增加了系统的复杂性</li>
                                <li id="8da29b80-ed6c-4af0-99ed-6e80f8b403b4"><i class="fas fa-times-circle"></i> 有时过度使用会导致代码难以理解和维护</li>
                                <li id="4188b1cb-058a-422a-bfcf-9acfaec06ee2"><i class="fas fa-times-circle"></i> 在某些情况下可能不如直接修改现有代码更简单</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="5c309559-5c79-42cc-b5f6-1d2d66647aba" class="mb-10 animated-element">
                        <h4 id="ec82551d-eff8-4a3e-94b1-a23fc1f3f65a" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="c2268e5a-0ff5-44fb-aef5-fc084c154e8c" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="f644a93c-b8ca-4c14-a4e6-c4021ea40691">需要使用现有的类，但其接口不符合你的要求</li>
                            <li id="bf499b0e-e4dd-4a36-ace8-efb4c35ae7cf">需要集成第三方库或遗留系统，但无法修改其源代码</li>
                            <li id="814d79ce-7dbd-4eb4-85a0-1c5100948902">需要统一多个类的接口设计时</li>
                        </ul>
                    </div>
                    
                    <div id="c0063f0e-bbc4-4cfa-b665-4214a497040a" class="animated-element">
                        <h4 id="046c200a-bfc3-4e97-af08-a3edbf7cc12d" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="f168722a-befd-4be0-bd13-38bd1448774a" class="code-block">
<pre><code class="language-cpp">// 目标接口（客户端期望的接口）
class MediaPlayer {
public:
    virtual ~MediaPlayer() = default;
    virtual void play(const std::string& audioType, const std::string& fileName) = 0;
};

// 被适配的类（已存在的接口）
class AdvancedMediaPlayer {
public:
    virtual ~AdvancedMediaPlayer() = default;
    virtual void playVlc(const std::string& fileName) = 0;
    virtual void playMp4(const std::string& fileName) = 0;
};

// 具体的高级播放器实现
class VlcPlayer : public AdvancedMediaPlayer {
public:
    void playVlc(const std::string& fileName) override {
        std::cout &lt;&lt; "播放VLC文件: " &lt;&lt; fileName &lt;&lt; std::endl;
    }
    
    void playMp4(const std::string& fileName) override {
        // 什么都不做，VlcPlayer不支持mp4
    }
};

class Mp4Player : public AdvancedMediaPlayer {
public:
    void playVlc(const std::string& fileName) override {
        // 什么都不做，Mp4Player不支持vlc
    }
    
    void playMp4(const std::string& fileName) override {
        std::cout &lt;&lt; "播放MP4文件: " &lt;&lt; fileName &lt;&lt; std::endl;
    }
};

// 适配器类，将AdvancedMediaPlayer适配为MediaPlayer
class MediaAdapter : public MediaPlayer {
private:
    std::unique_ptr&lt;AdvancedMediaPlayer&gt; advancedMusicPlayer_;
    
public:
    explicit MediaAdapter(const std::string& audioType) {
        if (audioType == "vlc") {
            advancedMusicPlayer_ = std::make_unique&lt;VlcPlayer&gt;();
        } else if (audioType == "mp4") {
            advancedMusicPlayer_ = std::make_unique&lt;Mp4Player&gt;();
        }
    }
    
    void play(const std::string& audioType, const std::string& fileName) override {
        if (audioType == "vlc") {
            advancedMusicPlayer_->playVlc(fileName);
        } else if (audioType == "mp4") {
            advancedMusicPlayer_->playMp4(fileName);
        }
    }
};

// 具体的播放器实现，使用适配器
class AudioPlayer : public MediaPlayer {
private:
    std::unique_ptr&lt;MediaAdapter&gt; mediaAdapter_;
    
public:
    void play(const std::string& audioType, const std::string& fileName) override {
        // 内置支持mp3格式
        if (audioType == "mp3") {
            std::cout &lt;&lt; "播放MP3文件: " &lt;&lt; fileName &lt;&lt; std::endl;
        } 
        // 使用适配器支持其他格式
        else if (audioType == "vlc" || audioType == "mp4") {
            mediaAdapter_ = std::make_unique&lt;MediaAdapter&gt;(audioType);
            mediaAdapter_->play(audioType, fileName);
        } else {
            std::cout &lt;&lt; "不支持的音频类型: " &lt;&lt; audioType &lt;&lt; std::endl;
        }
    }
};

// 客户端代码
int main() {
    AudioPlayer audioPlayer;
    
    audioPlayer.play("mp3", "beyond_the_horizon.mp3");
    audioPlayer.play("mp4", "alone.mp4");
    audioPlayer.play("vlc", "far_far_away.vlc");
    audioPlayer.play("avi", "mind_me.avi"); // 不支持的格式
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 命令模式 -->
            <div id="command" class="mb-32">
                <div id="0345ba53-6233-4789-b9be-2fb0e686515e" class="relative mb-12">
                    <div id="478a5e46-4156-40b7-b019-08db132bc5b0" class="animated-element">
                        <span id="0bc3c183-b252-4bbf-9220-d819fffcc813" class="number-accent text-purple-500">07</span>
                        <h3 id="6d9e5f74-01d8-42dd-b236-d00797d676dc" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">命令模式</h3>
                        <p id="df2e86d4-8565-4f88-8713-e530983fd665" class="text-xl text-gray-600 mb-6">Command Pattern</p>
                        <p id="1d45619a-e85e-4984-b404-b643fab6c254" class="text-lg text-gray-700 mb-8">
                            将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。命令模式实现了请求发送者与接收者解耦。
                        </p>
                    </div>
                    
                    <div id="e30d3708-1503-470c-a2b5-40612d63332e" class="chart-container animated-element">
                        <div id="command-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="7070000b-5791-47e2-92b1-0cac073d3c44" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="07c3b0fa-cf8f-4df1-96b3-e1ef24c866a6" class="animated-element">
                            <h4 id="ce242057-d8df-41a7-9680-ea836c80c656" class="text-xl font-bold mb-4 flex items-center">
                                <span id="cb370640-b9b7-4549-9fbe-342b769d6e0e" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="0092554a-7219-4ffd-a7c3-602277c0ab07" class="benefits-list">
                                <li id="c06db13b-05ae-4aa8-8294-904fdbe80674"><i class="fas fa-check-circle"></i> 将调用操作的对象与实现操作的对象解耦</li>
                                <li id="902d627b-c084-4f90-9edc-6b604bcaa653"><i class="fas fa-check-circle"></i> 可以实现命令的排队和日志</li>
                                <li id="c61e9489-b4bc-494b-b31e-1c4486f8b80f"><i class="fas fa-check-circle"></i> 支持撤销和重做操作</li>
                            </ul>
                        </div>
                        
                        <div id="82a75db4-09e2-4f3d-b233-3638176c1025" class="animated-element">
                            <h4 id="ac8c5b27-45e4-49d1-a767-35d71b9c7fe7" class="text-xl font-bold mb-4 flex items-center">
                                <span id="ecde96d4-42c8-4e9d-9434-7bec470cfb42" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="c9bd2cd9-a0a7-4889-a9c2-5523d6c4fc22" class="drawbacks-list">
                                <li id="af8635c0-ca55-4021-8bed-bdf1e8d42518"><i class="fas fa-times-circle"></i> 可能导致系统中存在大量具体命令类</li>
                                <li id="ea0a65e4-be94-481b-a4ce-c1ea0aabc145"><i class="fas fa-times-circle"></i> 命令模式实现复杂命令时可能变得困难</li>
                                <li id="6eb7ea4f-4212-405d-91d9-e628943fec62"><i class="fas fa-times-circle"></i> 增加了系统的复杂性</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="4f19f7e2-784d-402a-9e1b-ed90141babcd" class="mb-10 animated-element">
                        <h4 id="f41a812a-68d5-47a1-a618-717386665c68" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="3c40b5ba-cade-4889-86ed-15af7737cb14" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="09d0258e-729e-4c12-9d39-81bb8c4cd41c">需要将请求发送者和接收者解耦的场景</li>
                            <li id="9fdb7759-1d7d-4f1e-a535-bb3662570fc7">需要支持命令排队、命令日志或撤销功能时</li>
                            <li id="19d501f4-7737-45ac-8fcf-abc363653323">GUI应用中的菜单功能、宏命令或事务操作</li>
                        </ul>
                    </div>
                    
                    <div id="d3f01338-ae3a-4d92-ba83-17a4c1e54b7d" class="animated-element">
                        <h4 id="fc5bada1-3b06-4ece-8801-99dff0c56ae6" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="7fa9faef-b22d-4ef7-a9f9-8abc4b99b606" class="code-block">
<pre><code class="language-cpp">// 接收者类 - 执行命令相关的操作
class Light {
private:
    std::string location_;
    
public:
    explicit Light(const std::string& location) : location_(location) {}
    
    void on() {
        std::cout &lt;&lt; location_ &lt;&lt; " 灯已打开" &lt;&lt; std::endl;
    }
    
    void off() {
        std::cout &lt;&lt; location_ &lt;&lt; " 灯已关闭" &lt;&lt; std::endl;
    }
};

// 命令接口
class Command {
public:
    virtual ~Command() = default;
    virtual void execute() = 0;
    virtual void undo() = 0;
};

// 具体命令 - 开灯命令
class LightOnCommand : public Command {
private:
    Light* light_;
    
public:
    explicit LightOnCommand(Light* light) : light_(light) {}
    
    void execute() override {
        light_->on();
    }
    
    void undo() override {
        light_->off();
    }
};

// 具体命令 - 关灯命令
class LightOffCommand : public Command {
private:
    Light* light_;
    
public:
    explicit LightOffCommand(Light* light) : light_(light) {}
    
    void execute() override {
        light_->off();
    }
    
    void undo() override {
        light_->on();
    }
};

// 调用者类 - 简单遥控器
class SimpleRemoteControl {
private:
    Command* slot_;
    Command* lastCommand_;
    
public:
    SimpleRemoteControl() : slot_(nullptr), lastCommand_(nullptr) {}
    
    void setCommand(Command* command) {
        slot_ = command;
    }
    
    void buttonPressed() {
        if (slot_) {
            slot_->execute();
            lastCommand_ = slot_;
        }
    }
    
    void undoButtonPressed() {
        if (lastCommand_) {
            lastCommand_->undo();
        }
    }
};

// 宏命令 - 组合多个命令
class MacroCommand : public Command {
private:
    std::vector&lt;Command*&gt; commands_;
    
public:
    explicit MacroCommand(const std::vector&lt;Command*&gt;& commands) : commands_(commands) {}
    
    void execute() override {
        std::cout &lt;&lt; "执行宏命令 -- 开始" &lt;&lt; std::endl;
        for (auto command : commands_) {
            command->execute();
        }
        std::cout &lt;&lt; "执行宏命令 -- 结束" &lt;&lt; std::endl;
    }
    
    void undo() override {
        std::cout &lt;&lt; "撤销宏命令 -- 开始" &lt;&lt; std::endl;
        // 反向撤销命令
        for (auto it = commands_.rbegin(); it != commands_.rend(); ++it) {
            (*it)->undo();
        }
        std::cout &lt;&lt; "撤销宏命令 -- 结束" &lt;&lt; std::endl;
    }
};

// 客户端代码
int main() {
    // 创建接收者
    Light* livingRoomLight = new Light("客厅");
    Light* kitchenLight = new Light("厨房");
    
    // 创建具体命令
    Command* livingRoomLightOn = new LightOnCommand(livingRoomLight);
    Command* livingRoomLightOff = new LightOffCommand(livingRoomLight);
    Command* kitchenLightOn = new LightOnCommand(kitchenLight);
    Command* kitchenLightOff = new LightOffCommand(kitchenLight);
    
    // 创建调用者
    SimpleRemoteControl remote;
    
    // 测试单个命令
    std::cout &lt;&lt; "=== 测试单个命令 ===" &lt;&lt; std::endl;
    remote.setCommand(livingRoomLightOn);
    remote.buttonPressed();
    remote.undoButtonPressed();
    
    // 创建宏命令
    std::vector&lt;Command*&gt; partyOnCommands = {livingRoomLightOn, kitchenLightOn};
    std::vector&lt;Command*&gt; partyOffCommands = {livingRoomLightOff, kitchenLightOff};
    
    Command* partyOnMacro = new MacroCommand(partyOnCommands);
    Command* partyOffMacro = new MacroCommand(partyOffCommands);
    
    // 测试宏命令
    std::cout &lt;&lt; "\n=== 测试宏命令 ===" &lt;&lt; std::endl;
    std::cout &lt;&lt; "--- 派对开始 ---" &lt;&lt; std::endl;
    remote.setCommand(partyOnMacro);
    remote.buttonPressed();
    
    std::cout &lt;&lt; "\n--- 派对结束 ---" &lt;&lt; std::endl;
    remote.setCommand(partyOffMacro);
    remote.buttonPressed();
    
    std::cout &lt;&lt; "\n--- 撤销派对结束 ---" &lt;&lt; std::endl;
    remote.undoButtonPressed();
    
    // 清理资源
    delete livingRoomLight;
    delete kitchenLight;
    delete livingRoomLightOn;
    delete livingRoomLightOff;
    delete kitchenLightOn;
    delete kitchenLightOff;
    delete partyOnMacro;
    delete partyOffMacro;
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 代理模式 -->
            <div id="proxy" class="mb-32">
                <div id="e412d3c5-3e3c-416d-9e1d-4146efa32498" class="relative mb-12">
                    <div id="02cf66db-8ab9-4397-95fb-ed6771e1c871" class="animated-element">
                        <span id="0b11fedc-b34d-4bf2-b606-805f04da1944" class="number-accent text-purple-500">08</span>
                        <h3 id="fef5813a-bab7-4f7a-a9e0-f5798c7e92cc" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">代理模式</h3>
                        <p id="2b0c97f7-4518-487c-92ae-a1366de0b041" class="text-xl text-gray-600 mb-6">Proxy Pattern</p>
                        <p id="8c33cb83-2a44-4b44-9fbe-644d2580574a" class="text-lg text-gray-700 mb-8">
                            为其他对象提供一种代理以控制对这个对象的访问。代理模式可以在不改变原始对象的代码的情况下，增强对象的功能或控制对对象的访问。
                        </p>
                    </div>
                    
                    <div id="17ce5dd1-5749-4183-83cd-02874b266ed6" class="chart-container animated-element">
                        <div id="proxy-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="81d09eaf-b080-426d-94ce-9423f9e65643" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="653e9e3f-476d-4016-83e0-1bc83d49f859" class="animated-element">
                            <h4 id="519d70c4-c9cc-4f57-b533-4631c9cb8e64" class="text-xl font-bold mb-4 flex items-center">
                                <span id="d5ffe998-fd61-49e9-a553-94b103f970b4" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="6db82925-2911-48cd-8329-eebb7314b077" class="benefits-list">
                                <li id="1cb80602-c8a6-46f0-9f3b-71df26243ab5"><i class="fas fa-check-circle"></i> 在不修改原对象的情况下增强功能</li>
                                <li id="75861818-f05d-4015-9cbb-fd8a6bf8f989"><i class="fas fa-check-circle"></i> 控制对原对象的访问，提供保护</li>
                                <li id="e1d25a28-8a76-4d36-a2de-adccb8a8da83"><i class="fas fa-check-circle"></i> 可以延迟加载，提高性能</li>
                            </ul>
                        </div>
                        
                        <div id="aec40dec-e607-4eb8-aef4-a2714bc76bda" class="animated-element">
                            <h4 id="9c684a7d-9292-4294-a7c4-2b2f92317ed2" class="text-xl font-bold mb-4 flex items-center">
                                <span id="5bd0775d-e6b0-4521-9013-029f2d00e8fe" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="6679522c-ac80-4420-9e16-42fa11b30bb3" class="drawbacks-list">
                                <li id="8ded8293-0e6a-4a06-92ba-326cc063987d"><i class="fas fa-times-circle"></i> 增加系统复杂度</li>
                                <li id="1325810a-6a2b-4dff-8e3c-26ada0d8046b"><i class="fas fa-times-circle"></i> 可能引入性能延迟</li>
                                <li id="41352fb3-d7c4-46ba-8362-517d763fe8a6"><i class="fas fa-times-circle"></i> 实现远程代理可能会很复杂</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="397000af-b2f6-4fdb-bc1d-d02d6f9f2abb" class="mb-10 animated-element">
                        <h4 id="b9f704a0-3c5b-41c1-9bc4-61c775580f4f" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="50f88253-6527-4ffa-afba-e47e7fa6fa14" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="b851a008-7194-4ae1-be45-372a10cd403d">延迟加载（虚拟代理）：在需要时才创建开销很大的对象</li>
                            <li id="c9f23ae1-44d3-4999-90f0-117cc347c24d">访问控制（保护代理）：控制对原始对象的访问权限</li>
                            <li id="6d6a0ed5-8373-4601-99bb-9e3142913b22">远程调用（远程代理）：为远程对象提供本地代理</li>
                            <li id="9be07992-c33d-45ca-b90e-2f25d54fb5ee">记录日志（智能引用）：在访问对象前后进行额外操作</li>
                        </ul>
                    </div>
                    
                    <div id="4803d452-eccd-4cd6-8f15-31d1774eeb9e" class="animated-element">
                        <h4 id="e9e67fe7-5a89-4106-aead-67b1f3b93aa4" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="cc241a6d-c916-407c-afca-b5396006142c" class="code-block">
<pre><code class="language-cpp">// 主题接口
class Subject {
public:
    virtual ~Subject() = default;
    virtual void request() const = 0;
};

// 真实主题
class RealSubject : public Subject {
public:
    void request() const override {
        std::cout &lt;&lt; "RealSubject: 处理请求" &lt;&lt; std::endl;
    }
};

// 代理
class Proxy : public Subject {
private:
    RealSubject* realSubject_;
    bool ownRealSubject_;
    
    bool checkAccess() const {
        // 这里进行访问控制检查
        std::cout &lt;&lt; "Proxy: 检查访问权限" &lt;&lt; std::endl;
        return true;
    }
    
    void logAccess() const {
        std::cout &lt;&lt; "Proxy: 记录访问时间: " 
                  &lt;&lt; std::time(nullptr) &lt;&lt; std::endl;
    }
    
public:
    // 构造函数，可以接受已有实例或创建新实例
    explicit Proxy(RealSubject* realSubject = nullptr)
        : realSubject_(realSubject), ownRealSubject_(realSubject == nullptr) {
        
        if (ownRealSubject_) {
            realSubject_ = new RealSubject();
        }
    }
    
    ~Proxy() {
        if (ownRealSubject_) {
            delete realSubject_;
        }
    }
    
    // 代理方法，在调用实际对象前后添加额外操作
    void request() const override {
        if (checkAccess()) {
            std::cout &lt;&lt; "Proxy: 预处理" &lt;&lt; std::endl;
            
            realSubject_->request();
            
            std::cout &lt;&lt; "Proxy: 后处理" &lt;&lt; std::endl;
            logAccess();
        } else {
            std::cout &lt;&lt; "Proxy: 请求被拒绝" &lt;&lt; std::endl;
        }
    }
};

// 延迟加载的虚拟代理
class VirtualProxy : public Subject {
private:
    RealSubject* realSubject_;
    mutable bool initialized_;
    
    void initialize() const {
        if (!initialized_) {
            std::cout &lt;&lt; "VirtualProxy: 延迟加载实际对象" &lt;&lt; std::endl;
            realSubject_ = new RealSubject();
            initialized_ = true;
        }
    }
    
public:
    VirtualProxy() : realSubject_(nullptr), initialized_(false) {}
    
    ~VirtualProxy() {
        delete realSubject_;
    }
    
    void request() const override {
        initialize();
        realSubject_->request();
    }
};

// 缓存代理示例
class CachingProxy : public Subject {
private:
    RealSubject* realSubject_;
    mutable std::map&lt;std::string, std::string&gt; cache_;
    
public:
    explicit CachingProxy(RealSubject* realSubject) 
        : realSubject_(realSubject) {}
    
    void request() const override {
        std::string key = "request_key"; // 实际应用中，这可能是一个参数
        
        // 检查缓存
        if (cache_.find(key) != cache_.end()) {
            std::cout &lt;&lt; "CachingProxy: 返回缓存结果: " 
                      &lt;&lt; cache_[key] &lt;&lt; std::endl;
            return;
        }
        
        // 没有缓存，调用实际对象
        realSubject_->request();
        
        // 缓存结果
        cache_[key] = "result"; // 实际应用中，应该缓存实际结果
        std::cout &lt;&lt; "CachingProxy: 结果已缓存" &lt;&lt; std::endl;
    }
};

// 客户端代码
void clientCode(const Subject& subject) {
    subject.request();
}

int main() {
    std::cout &lt;&lt; "客户端: 直接调用真实主题:" &lt;&lt; std::endl;
    RealSubject realSubject;
    clientCode(realSubject);
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "客户端: 通过代理调用真实主题:" &lt;&lt; std::endl;
    Proxy proxy(&realSubject);
    clientCode(proxy);
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "客户端: 通过虚拟代理调用真实主题:" &lt;&lt; std::endl;
    VirtualProxy virtualProxy;
    std::cout &lt;&lt; "第一次调用:" &lt;&lt; std::endl;
    clientCode(virtualProxy);
    std::cout &lt;&lt; "第二次调用:" &lt;&lt; std::endl;
    clientCode(virtualProxy);
    std::cout &lt;&lt; std::endl;
    
    std::cout &lt;&lt; "客户端: 通过缓存代理调用真实主题:" &lt;&lt; std::endl;
    CachingProxy cachingProxy(&realSubject);
    std::cout &lt;&lt; "第一次调用:" &lt;&lt; std::endl;
    clientCode(cachingProxy);
    std::cout &lt;&lt; "第二次调用:" &lt;&lt; std::endl;
    clientCode(cachingProxy);
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 模板方法模式 -->
            <div id="template" class="mb-32">
                <div id="aa69bf3e-6b80-4b8f-a6a5-c20fb6cd650a" class="relative mb-12">
                    <div id="065e6c7f-6475-4f48-bf57-6a4fe693bfbb" class="animated-element">
                        <span id="3e0d5105-4485-40c5-ad3f-c7302911a7fa" class="number-accent text-purple-500">09</span>
                        <h3 id="d01f64bd-0394-4a52-87d6-762efe7255a8" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">模板方法模式</h3>
                        <p id="d2ff7897-8a28-406a-962b-8e01a055ca0b" class="text-xl text-gray-600 mb-6">Template Method Pattern</p>
                        <p id="c7bdff5a-a2f5-4780-a116-8acc4eb84284" class="text-lg text-gray-700 mb-8">
                            定义一个操作中的算法骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
                        </p>
                    </div>
                    
                    <div id="0516a4c6-70a4-4f32-ab2c-e6012c013e8d" class="chart-container animated-element">
                        <div id="template-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="8844dfe5-4897-40eb-a1c5-0a82942d4057" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="e5b5554f-9e9c-4f12-a964-9e790db2f3eb" class="animated-element">
                            <h4 id="fde20945-513f-4bde-bb72-8354bdebf4f2" class="text-xl font-bold mb-4 flex items-center">
                                <span id="935a3d54-bc74-4604-b657-cb2d7926fe48" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="24c739dd-355a-4c03-bc28-64b3b4f2b7af" class="benefits-list">
                                <li id="66660097-7a79-4ce5-a03b-1f396c6c7deb"><i class="fas fa-check-circle"></i> 封装不变部分，扩展可变部分</li>
                                <li id="a6ca6c45-91a3-4649-8e0a-030d9755028f"><i class="fas fa-check-circle"></i> 提取公共代码，便于维护</li>
                                <li id="20eef652-cec9-4841-bacd-7bb19aa52f57"><i class="fas fa-check-circle"></i> 通过钩子方法灵活控制算法</li>
                            </ul>
                        </div>
                        
                        <div id="fb1fa3d5-afd0-4ed2-97ec-0f14a0c03616" class="animated-element">
                            <h4 id="d8243d71-1e53-453e-a531-415a558e2313" class="text-xl font-bold mb-4 flex items-center">
                                <span id="9e7be965-a8c6-4e0c-94a0-d2ec09b1d91a" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="c25e0185-c9e6-4b06-81b6-7dad774eff8f" class="drawbacks-list">
                                <li id="343d7f08-e50a-4304-9a2d-0ca9d31ae21e"><i class="fas fa-times-circle"></i> 每个不同的实现都需要一个子类</li>
                                <li id="9c30e712-9145-4d6c-8a9e-11ae791180fd"><i class="fas fa-times-circle"></i> 增加了系统复杂度</li>
                                <li id="6ca400cb-7ef8-4954-8387-c6ba12792ad2"><i class="fas fa-times-circle"></i> 继承关系自身缺点，如果父类增加新的抽象方法，所有子类都要改</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="36eb5b5d-a59c-4685-8aa7-f9b5e7dd762d" class="mb-10 animated-element">
                        <h4 id="75482524-828c-4493-b857-b5bc1a14b41e" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="1b028f34-d861-4a7a-80c3-5d7791edc2c9" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="510c8b5b-f7af-45ef-b7d6-e56a0f6eb66c">多个类有相似的算法骨架，但具体步骤不同</li>
                            <li id="e3c29895-aee4-42f8-a118-db87aafa8bdb">将算法的不变部分和变化部分分离，以提高代码复用性</li>
                            <li id="8a122c75-f17b-4cc6-bcb0-66fd1db821c9">控制子类扩展的方式和范围</li>
                        </ul>
                    </div>
                    
                    <div id="6f9277f5-9e03-4cfb-8825-1f45cb448500" class="animated-element">
                        <h4 id="6636ba75-de13-4ccb-a3ef-15b079ab322b" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="67aea2e6-a5dc-4294-b912-ae63bf85833b" class="code-block">
<pre><code class="language-cpp">// 抽象类，定义模板方法和原语操作
class AbstractClass {
public:
    // 模板方法，定义了算法骨架
    void templateMethod() const {
        // 算法的固定步骤
        baseOperation1();
        requiredOperation1();
        baseOperation2();
        hook1();
        requiredOperation2();
        baseOperation3();
        hook2();
    }
    
    virtual ~AbstractClass() = default;
    
protected:
    // 基本操作，已在抽象类中实现
    void baseOperation1() const {
        std::cout &lt;&lt; "AbstractClass: 执行基本操作1\n";
    }
    
    void baseOperation2() const {
        std::cout &lt;&lt; "AbstractClass: 执行基本操作2\n";
    }
    
    void baseOperation3() const {
        std::cout &lt;&lt; "AbstractClass: 执行基本操作3\n";
    }
    
    // 必须由子类实现的抽象操作
    virtual void requiredOperation1() const = 0;
    virtual void requiredOperation2() const = 0;
    
    // 钩子方法，子类可以选择性重写
    virtual void hook1() const {}
    virtual void hook2() const {}
};

// 具体类A
class ConcreteClassA : public AbstractClass {
protected:
    void requiredOperation1() const override {
        std::cout &lt;&lt; "ConcreteClassA: 实现操作1\n";
    }
    
    void requiredOperation2() const override {
        std::cout &lt;&lt; "ConcreteClassA: 实现操作2\n";
    }
    
    void hook1() const override {
        std::cout &lt;&lt; "ConcreteClassA: 重写钩子1\n";
    }
};

// 具体类B
class ConcreteClassB : public AbstractClass {
protected:
    void requiredOperation1() const override {
        std::cout &lt;&lt; "ConcreteClassB: 实现操作1\n";
    }
    
    void requiredOperation2() const override {
        std::cout &lt;&lt; "ConcreteClassB: 实现操作2\n";
    }
    
    void hook2() const override {
        std::cout &lt;&lt; "ConcreteClassB: 重写钩子2\n";
    }
};

// 数据处理实例
class DataProcessor {
public:
    virtual ~DataProcessor() = default;
    
    // 模板方法定义了数据处理算法
    void processData() {
        openFile();
        extractData();
        transformData();
        analyze();
        sendReport();
        closeFile();
    }
    
protected:
    void openFile() {
        std::cout &lt;&lt; "打开数据文件\n";
    }
    
    void closeFile() {
        std::cout &lt;&lt; "关闭数据文件\n";
    }
    
    // 需要子类实现的抽象方法
    virtual void extractData() = 0;
    virtual void transformData() = 0;
    virtual void analyze() = 0;
    virtual void sendReport() = 0;
};

// CSV数据处理器
class CSVProcessor : public DataProcessor {
protected:
    void extractData() override {
        std::cout &lt;&lt; "从CSV文件中提取数据\n";
    }
    
    void transformData() override {
        std::cout &lt;&lt; "转换CSV数据格式\n";
    }
    
    void analyze() override {
        std::cout &lt;&lt; "分析CSV数据\n";
    }
    
    void sendReport() override {
        std::cout &lt;&lt; "生成CSV分析报告\n";
    }
};

// JSON数据处理器
class JSONProcessor : public DataProcessor {
protected:
    void extractData() override {
        std::cout &lt;&lt; "从JSON文件中提取数据\n";
    }
    
    void transformData() override {
        std::cout &lt;&lt; "转换JSON数据格式\n";
    }
    
    void analyze() override {
        std::cout &lt;&lt; "分析JSON数据\n";
    }
    
    void sendReport() override {
        std::cout &lt;&lt; "生成JSON分析报告\n";
    }
};

// 客户端代码
void clientCode(AbstractClass* abstractClass) {
    // 调用模板方法，执行算法
    abstractClass->templateMethod();
}

int main() {
    std::cout &lt;&lt; "基础示例演示:\n";
    ConcreteClassA* concreteA = new ConcreteClassA();
    clientCode(concreteA);
    std::cout &lt;&lt; "\n";
    
    ConcreteClassB* concreteB = new ConcreteClassB();
    clientCode(concreteB);
    
    std::cout &lt;&lt; "\n数据处理示例演示:\n";
    std::cout &lt;&lt; "处理CSV数据:\n";
    CSVProcessor csvProcessor;
    csvProcessor.processData();
    
    std::cout &lt;&lt; "\n处理JSON数据:\n";
    JSONProcessor jsonProcessor;
    jsonProcessor.processData();
    
    delete concreteA;
    delete concreteB;
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 组合模式 -->
            <div id="composite" class="mb-32">
                <div id="c931b226-74d3-45a4-a426-15619d8247d4" class="relative mb-12">
                    <div id="f8293e36-7e4d-48e8-b7b8-b65132c83f52" class="animated-element">
                        <span id="e7e3fe63-2119-4316-943c-a63d8318dfd4" class="number-accent text-purple-500">10</span>
                        <h3 id="24066067-bec8-4452-b893-330210d6ebaa" class="text-3xl md:text-4xl font-bold mb-4 pattern-accent">组合模式</h3>
                        <p id="ceb1541f-57e5-4b3d-b843-d783d9de3579" class="text-xl text-gray-600 mb-6">Composite Pattern</p>
                        <p id="2fc9b7ea-0c8d-4113-a436-517bee20f4a9" class="text-lg text-gray-700 mb-8">
                            将对象组合成树形结构以表示"部分-整体"的层次结构，使得用户对单个对象和组合对象的使用具有一致性。组合模式使得客户端可以统一对待单个对象和对象组合。
                        </p>
                    </div>
                    
                    <div id="b5f7f125-160d-44bf-a612-56dcee58c8bf" class="chart-container animated-element">
                        <div id="composite-chart" style="width: 100%; height: 300px;"></div>
                    </div>
                    
                    <div id="52d9c553-f4fb-4e1a-a358-84faf27512c0" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-10">
                        <div id="7d429269-5b08-49c8-a55c-0253cd173d08" class="animated-element">
                            <h4 id="889ba967-263e-4112-9e26-ffb43f83ad36" class="text-xl font-bold mb-4 flex items-center">
                                <span id="0034c982-2d79-4b9c-aae0-1e097e8880ec" class="w-8 h-8 rounded-full bg-green-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-plus"></i>
                                </span>
                                优点
                            </h4>
                            <ul id="5503d03c-b674-40e7-9761-54bf23710713" class="benefits-list">
                                <li id="a52d86fc-ab8d-4389-8401-b69a41e96456"><i class="fas fa-check-circle"></i> 定义了包含基本对象和复合对象的类层次结构</li>
                                <li id="043acf55-9f96-4df0-9912-1a71881bc47d"><i class="fas fa-check-circle"></i> 使客户端代码可以统一处理单个对象和组合对象</li>
                                <li id="715ced6e-6046-439a-b0c0-db98e4f18ac4"><i class="fas fa-check-circle"></i> 使添加新组件变得容易，符合开闭原则</li>
                            </ul>
                        </div>
                        
                        <div id="fc266c73-ffe4-4b29-9640-84376556873e" class="animated-element">
                            <h4 id="301f8325-0412-4338-94c5-1922609e3211" class="text-xl font-bold mb-4 flex items-center">
                                <span id="3f4f8ae4-7e32-46f3-ba15-796acddb5b91" class="w-8 h-8 rounded-full bg-red-500 flex items-center justify-center text-white mr-2">
                                    <i class="fas fa-minus"></i>
                                </span>
                                缺点
                            </h4>
                            <ul id="e66e5154-4262-48f7-82cb-f2a175b224f1" class="drawbacks-list">
                                <li id="4a0157cc-518a-4562-a665-ea9c541881d3"><i class="fas fa-times-circle"></i> 在特定情况下很难限制组件的类型</li>
                                <li id="006fb073-9c2b-43c4-ac80-0af0f89ba425"><i class="fas fa-times-circle"></i> 接口设计可能会变得过于一般化</li>
                                <li id="b0284ae1-bc52-4043-b37f-84ab420d4380"><i class="fas fa-times-circle"></i> 可能会使设计变得过于复杂</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div id="ee162aa2-f9d0-4395-bfb5-5c80a6ff61d8" class="mb-10 animated-element">
                        <h4 id="a5885129-ace2-4fc6-9d18-f27df7d505c9" class="text-xl font-bold mb-4">使用场景</h4>
                        <ul id="d6f1bb0d-0e76-47a0-a5d4-64a557a354b5" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="0fd027c8-c8d0-4b40-ba1d-10c98cb9730c">需要表示对象的部分-整体层次结构时</li>
                            <li id="4b05e682-71a9-4790-9353-e8ff32ade0e1">希望客户端忽略单个对象和组合对象的差别</li>
                            <li id="20ec585a-2dc9-4cea-ae19-529763573c2f">GUI组件树、文件系统管理、组织架构等</li>
                        </ul>
                    </div>
                    
                    <div id="c5be5ec6-f1c6-4f67-8725-a7bcc4b89f8d" class="animated-element">
                        <h4 id="3845b29f-f13c-44eb-84fc-d85b4ae10fe4" class="text-xl font-bold mb-4">C++ 实现</h4>
                        <div id="ca3fa9a2-7bcb-448a-8a32-f150aebc4bcc" class="code-block">
<pre><code class="language-cpp">// 组件抽象类
class Component {
protected:
    Component* parent_;
    
public:
    Component() : parent_(nullptr) {}
    virtual ~Component() = default;
    
    void setParent(Component* parent) {
        parent_ = parent;
    }
    
    Component* getParent() const {
        return parent_;
    }
    
    // 在组件中添加子组件
    virtual void add(Component* component) {
        throw std::runtime_error("无法添加子组件");
    }
    
    // 移除子组件
    virtual void remove(Component* component) {
        throw std::runtime_error("无法移除子组件");
    }
    
    // 检查是否是复合对象
    virtual bool isComposite() const {
        return false;
    }
    
    // 执行组件操作
    virtual std::string operation() const = 0;
};

// 叶子节点 - 不包含子组件的基本对象
class Leaf : public Component {
public:
    explicit Leaf(const std::string& name) : name_(name) {}
    
    std::string operation() const override {
        return name_;
    }
    
private:
    std::string name_;
};

// 复合节点 - 可以包含叶子节点或其他复合节点
class Composite : public Component {
private:
    std::vector&lt;Component*&gt; children_;
    std::string name_;
    
public:
    explicit Composite(const std::string& name) : name_(name) {}
    
    ~Composite() override {
        for (auto child : children_) {
            delete child;
        }
    }
    
    void add(Component* component) override {
        children_.push_back(component);
        component->setParent(this);
    }
    
    void remove(Component* component) override {
        auto it = std::find(children_.begin(), children_.end(), component);
        if (it != children_.end()) {
            (*it)->setParent(nullptr);
            children_.erase(it);
        }
    }
    
    bool isComposite() const override {
        return true;
    }
    
    // 递归执行所有子组件的操作
    std::string operation() const override {
        std::string result = name_ + " [ ";
        
        for (size_t i = 0; i < children_.size(); ++i) {
            result += children_[i]->operation();
            if (i != children_.size() - 1) {
                result += ", ";
            }
        }
        
        return result + " ]";
    }
};

// 文件系统示例
class FileSystemComponent {
public:
    virtual ~FileSystemComponent() = default;
    virtual std::string getName() const = 0;
    virtual int getSize() const = 0;
    virtual void display(int depth = 0) const = 0;
    virtual void add(FileSystemComponent* component) {
        throw std::runtime_error("不支持添加操作");
    }
    virtual void remove(FileSystemComponent* component) {
        throw std::runtime_error("不支持移除操作");
    }
};

// 文件类
class File : public FileSystemComponent {
private:
    std::string name_;
    int size_;
    
public:
    File(const std::string& name, int size) : name_(name), size_(size) {}
    
    std::string getName() const override {
        return name_;
    }
    
    int getSize() const override {
        return size_;
    }
    
    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout &lt;&lt; indent &lt;&lt; "- " &lt;&lt; name_ &lt;&lt; " (" &lt;&lt; size_ &lt;&lt; "KB)" &lt;&lt; std::endl;
    }
};

// 文件夹类
class Directory : public FileSystemComponent {
private:
    std::string name_;
    std::vector&lt;FileSystemComponent*&gt; children_;
    
public:
    explicit Directory(const std::string& name) : name_(name) {}
    
    ~Directory() {
        for (auto child : children_) {
            delete child;
        }
    }
    
    std::string getName() const override {
        return name_;
    }
    
    int getSize() const override {
        int totalSize = 0;
        for (auto child : children_) {
            totalSize += child->getSize();
        }
        return totalSize;
    }
    
    void add(FileSystemComponent* component) override {
        children_.push_back(component);
    }
    
    void remove(FileSystemComponent* component) override {
        auto it = std::find(children_.begin(), children_.end(), component);
        if (it != children_.end()) {
            children_.erase(it);
        }
    }
    
    void display(int depth = 0) const override {
        std::string indent(depth * 2, ' ');
        std::cout &lt;&lt; indent &lt;&lt; "+ " &lt;&lt; name_ 
                  &lt;&lt; " (" &lt;&lt; getSize() &lt;&lt; "KB)" &lt;&lt; std::endl;
        
        for (const auto& child : children_) {
            child->display(depth + 1);
        }
    }
};

// 客户端代码
int main() {
    // 基本示例
    std::cout &lt;&lt; "基本组合模式示例:\n";
    
    Leaf* leaf1 = new Leaf("Leaf 1");
    Leaf* leaf2 = new Leaf("Leaf 2");
    Leaf* leaf3 = new Leaf("Leaf 3");
    
    Composite* branch1 = new Composite("Branch 1");
    branch1->add(leaf1);
    branch1->add(leaf2);
    
    Composite* branch2 = new Composite("Branch 2");
    branch2->add(leaf3);
    
    Composite* tree = new Composite("Tree");
    tree->add(branch1);
    tree->add(branch2);
    
    std::cout &lt;&lt; "树结构: " &lt;&lt; tree->operation() &lt;&lt; std::endl;
    
    delete tree;
    
    // 文件系统示例
    std::cout &lt;&lt; "\n文件系统示例:\n";
    
    Directory* root = new Directory("root");
    
    Directory* documents = new Directory("documents");
    Directory* pictures = new Directory("pictures");
    
    File* file1 = new File("report.doc", 100);
    File* file2 = new File("presentation.ppt", 2500);
    File* pic1 = new File("vacation.jpg", 3000);
    File* pic2 = new File("family.png", 2000);
    
    documents->add(file1);
    documents->add(file2);
    
    pictures->add(pic1);
    pictures->add(pic2);
    
    root->add(documents);
    root->add(pictures);
    
    root->display();
    
    std::cout &lt;&lt; "\n根目录总大小: " &lt;&lt; root->getSize() &lt;&lt; "KB" &lt;&lt; std::endl;
    std::cout &lt;&lt; "文档目录总大小: " &lt;&lt; documents->getSize() &lt;&lt; "KB" &lt;&lt; std::endl;
    std::cout &lt;&lt; "图片目录总大小: " &lt;&lt; pictures->getSize() &lt;&lt; "KB" &lt;&lt; std::endl;
    
    delete root;
    
    return 0;
}</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- 如何选择设计模式 -->
    <section id="guide" class="py-16 bg-gray-50">
        <div id="be32a0c8-20bf-41b7-b805-ee23efddc92d" class="container mx-auto px-4 md:px-6">
            <div id="60a8fe3e-e264-4c3a-a021-65e196127bd0" class="max-w-4xl mx-auto">
                <h2 id="de7a8ffa-d896-4269-b4c9-d3c7ac714273" class="text-3xl md:text-4xl font-bold mb-8 text-center animated-element">
                    <span id="fb2eae05-485c-4371-91a3-c06a7967157f" class="pattern-accent">如何选择合适的设计模式</span>
                </h2>
                
                <div id="4d0323e4-08e9-4587-943a-8a2b9b72d3e8" class="mb-10 animated-element">
                    <p id="f30a20f3-f3d3-47b9-8cce-94ce5a42d9fa" class="text-lg text-gray-700 mb-6">
                        设计模式是解决软件设计中特定问题的模板，然而每种模式都有其适用场景。以下是选择合适设计模式的指导原则：
                    </p>
                </div>
                
                <div id="079cd780-149c-42ff-bbc1-5551a9ad74fe" class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-12">
                    <div id="d6b4d2d6-3a20-4b6a-93a0-2284c4c4d5a6" class="card p-6 animated-element">
                        <h3 id="18a91ef3-dc25-42fc-b87c-a519a5bfce43" class="text-xl font-bold mb-4">基于问题识别</h3>
                        <ul id="e9fec2d6-6ee1-417e-9ebf-af0e153b6478" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="8681e446-153e-4ac7-b68a-9e78f5597f8c">明确你要解决的是什么问题</li>
                            <li id="96810d66-8c15-4c48-961e-39596af1a714">查找该问题对应的设计模式</li>
                            <li id="294d4764-6ae9-4034-ab2a-84cf37bb482d">参考设计模式的意图和适用性部分</li>
                        </ul>
                    </div>
                    
                    <div id="13c08998-8066-4089-b12e-de302d76f1e6" class="card p-6 animated-element">
                        <h3 id="c8e7af76-e020-49b6-8716-2463072c6e2e" class="text-xl font-bold mb-4">考虑系统上下文</h3>
                        <ul id="f8f89927-20e2-49ab-8728-29e686acf848" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="1cb7fd30-185e-4623-bc19-c4e2e8027ced">评估模式是否与现有架构兼容</li>
                            <li id="7b8e5e35-8c97-4b90-aa19-4118433a56e2">考虑团队对该模式的熟悉度</li>
                            <li id="0feac47d-a1f8-4712-8d08-d82fdde8e156">思考模式的长期维护成本</li>
                        </ul>
                    </div>
                    
                    <div id="4b4b660d-ea62-4bd4-8fa4-fe9f7e8f8280" class="card p-6 animated-element">
                        <h3 id="8f9941b1-5723-4eab-b12e-f5df1f91e57f" class="text-xl font-bold mb-4">权衡利弊</h3>
                        <ul id="02e51020-4c0d-4d9e-8c38-3af458fed665" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="7dd34a25-5202-49c4-b084-7a99e93a5e9f">每种模式都有优缺点，避免过度设计</li>
                            <li id="967b4146-c6c1-49eb-8f12-e249f64f46ad">权衡设计的灵活性与复杂性</li>
                            <li id="e56e3c86-42e0-44b5-8da2-2dd91f623ec6">有时简单直接的解决方案比模式更适合</li>
                        </ul>
                    </div>
                    
                    <div id="3e7f2839-12fd-45af-a779-ed847d1a81a4" class="card p-6 animated-element">
                        <h3 id="b30dcafd-80dd-457f-8dcf-f94696aec4c7" class="text-xl font-bold mb-4">组合使用模式</h3>
                        <ul id="0b605d6a-7976-429d-947c-1c2c8ccce137" class="list-disc pl-6 text-gray-700 space-y-2">
                            <li id="bfa553fd-8006-4b35-ae24-ac9faa5274b8">设计模式通常可以组合使用</li>
                            <li id="92ed260d-4a21-47e4-a02a-da764959d932">有些模式自然地相互补充</li>
                            <li id="eaf5b6b1-d4b1-481d-9f7b-916c33570f70">学习常见的模式组合方式</li>
                        </ul>
                    </div>
                </div>
                
                <div id="6b9bf983-8a08-4a2e-b0b3-ea386d2bdf99" class="chart-container animated-element">
                    <div id="pattern-selection-chart" style="width: 100%; height: 400px;"></div>
                </div>
                
                <div id="a3f159d8-7e12-43c1-9b00-c9ab5a6402a4" class="mt-12 animated-element">
                    <h3 id="1558d6e2-f314-4af8-bc8a-e6f19e3e874d" class="text-xl font-bold mb-6">常见设计问题与推荐模式</h3>
                    <div id="6ed22ae8-e735-4819-9afa-86661819bc34" class="overflow-auto">
                        <table id="345139c8-9445-468f-b2d0-02bce62a112e" class="min-w-full bg-white border rounded-lg">
                            <thead id="5b5ab147-d930-4a25-8a7f-e055ef8b8ab0" class="bg-gray-100">
                                <tr id="b1ca4809-aeee-424e-9924-36e92c5f5588">
                                    <th id="11d99b1b-84cb-4fa5-85fc-c615fc42d97a" class="py-3 px-4 text-left border-b">设计问题</th>
                                    <th id="aedbd82f-5445-4fed-bac4-57e568234329" class="py-3 px-4 text-left border-b">推荐模式</th>
                                    <th id="9f0aef92-6ecb-4bd3-bef7-6f8728bf6f9a" class="py-3 px-4 text-left border-b">原因</th>
                                </tr>
                            </thead>
                            <tbody id="6afbcde8-a9f8-4b16-a3e5-d87e27843dca">
                                <tr id="a1042a8a-8722-48d0-9833-bc7c38e1be9d">
                                    <td id="0c63267c-f566-469a-8874-d4a2594e7574" class="py-3 px-4 border-b">需要确保一个类只有一个实例</td>
                                    <td id="d95f3375-aad3-4ebd-b09e-390bd755e7b9" class="py-3 px-4 border-b">单例模式</td>
                                    <td id="a25a41e2-6bee-4038-b809-90a6d1a84695" class="py-3 px-4 border-b">控制资源访问，提供全局访问点</td>
                                </tr>
                                <tr id="f70c5f65-f509-4375-89d1-e279c5c1f4ce" class="bg-gray-50">
                                    <td id="fb3e2a9f-cd67-429d-9a5c-d6fe2e241329" class="py-3 px-4 border-b">对象创建逻辑复杂或需要解耦</td>
                                    <td id="931ab851-6475-41cc-8d89-72c0186ec167" class="py-3 px-4 border-b">工厂方法模式</td>
                                    <td id="2958fb8d-1c82-4a4c-9611-0961ad6abc33" class="py-3 px-4 border-b">分离对象创建和使用，支持扩展</td>
                                </tr>
                                <tr id="567f7ca2-35dc-4b1a-b381-4c0d6d2d6cff">
                                    <td id="c1a4991f-6744-49ea-9ef8-5254a137f610" class="py-3 px-4 border-b">需要通知多个对象状态变化</td>
                                    <td id="45a7bb01-2456-4e59-b6a5-c5f886e66d20" class="py-3 px-4 border-b">观察者模式</td>
                                    <td id="823f07d9-b002-468c-851e-9496224f9ce3" class="py-3 px-4 border-b">实现松耦合的对象通知机制</td>
                                </tr>
                                <tr id="c874e3d6-b6d8-4ed6-a135-1aabaa1fa778" class="bg-gray-50">
                                    <td id="2533e77d-3fc9-495f-a38d-c1ef800ffa58" class="py-3 px-4 border-b">需要动态选择算法实现</td>
                                    <td id="b8fe25e7-c560-4903-8396-7086482db020" class="py-3 px-4 border-b">策略模式</td>
                                    <td id="5d90d89e-07fe-4f18-a52a-741704ff1c20" class="py-3 px-4 border-b">封装算法族，支持运行时切换</td>
                                </tr>
                                <tr id="ee6755ca-c263-4a11-98d3-6852781c7670">
                                    <td id="b1097d0e-5192-4bb4-91b9-6d019592c90c" class="py-3 px-4 border-b">需要动态添加功能且不修改原类</td>
                                    <td id="5f47cfe8-6cb8-4ceb-b5b0-43319922e6c8" class="py-3 px-4 border-b">装饰器模式</td>
                                    <td id="885860f2-c901-457c-8fae-c0c6efcb3ab4" class="py-3 px-4 border-b">灵活组合功能，避免类爆炸</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- 页脚 -->
    <footer id="footer" class="bg-gray-800 text-white py-8">
        <div id="26ddfbe5-9154-42e7-9348-e7000b5388c9" class="container mx-auto px-4 md:px-6">
            <div id="4e66bb9d-859a-4edc-9e23-1ee22f3a8dc5" class="flex flex-col md:flex-row justify-between">
                <div id="63e65b67-b251-4ed6-b028-ba5734426580" class="mb-6 md:mb-0">
                    <h3 id="83c92816-e17c-4e95-82c7-a0dedf53b07d" class="text-lg font-bold mb-2">设计模式详解</h3>
                    <p id="8de1e6f4-0320-4244-8b64-29c15ade3483" class="text-sm text-gray-400">优缺点、使用场景与C++实现</p>
                </div>
                <div id="71945131-e5ad-4cd0-86e2-5b8703be4d4e" class="grid grid-cols-2 gap-8">
                    <div id="7fbd729c-c3ee-4493-aa43-e143c9cc9e40">
                        <h4 id="c98aed8a-a5e7-4c48-b69a-eed523c7c876" class="text-md font-semibold mb-4">快速导航</h4>
                        <ul id="994be283-08d5-4440-bc03-694d8956aadc" class="text-sm space-y-2">
                            <li id="e0d87c77-9abc-458c-a8e7-9532d3e31108"><a href="#intro" class="text-gray-400 hover:text-white">简介</a></li>
                            <li id="a4124791-98ea-4a50-9553-1b2a520c4ceb"><a href="#patterns" class="text-gray-400 hover:text-white">设计模式</a></li>
                            <li id="4fb75462-7324-4c13-b6fa-d5e8647e6893"><a href="#guide" class="text-gray-400 hover:text-white">选择指南</a></li>
                        </ul>
                    </div>
                    <div id="f3366ebe-edf3-4e59-9a46-b4dcc4533af9">
                        <h4 id="9a83cebe-cbcf-41e8-b40c-3faab4c4ec15" class="text-md font-semibold mb-4">资源</h4>
                        <ul id="bff5f8fe-42fd-4ddb-ae08-0d5c7c9e07d4" class="text-sm space-y-2">
                            <li id="948585e9-a7b1-4afa-9ab9-5a299c8c1436"><a href="#" class="text-gray-400 hover:text-white">设计模式书籍</a></li>
                            <li id="05d9c374-df98-47f6-bf81-1235201a2c1e"><a href="#" class="text-gray-400 hover:text-white">C++学习资源</a></li>
                            <li id="c399387a-6881-4b5c-85c7-6edf5e22e127"><a href="#" class="text-gray-400 hover:text-white">更多模式示例</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div id="502d5224-b659-4cad-9280-93be7e9c859c" class="mt-8 pt-8 border-t border-gray-700 text-center text-sm text-gray-500">
                <p id="6bd0e9bb-77cf-495a-b0a5-633ab3a5aefe">© 2025 设计模式详解. 图片来源: <a href="https://unsplash.com" class="underline">Unsplash</a>.</p>
            </div>
        </div>
    </footer>

    <!-- 回到顶部按钮 -->
    <button id="back-to-top" class="fixed bottom-8 right-8 bg-blue-600 text-white w-12 h-12 rounded-full flex items-center justify-center shadow-lg opacity-0 transition-opacity duration-300">
        <i class="fas fa-arrow-up"></i>
    </button>

    <script>
        // 初始化 ECharts 图表
        document.addEventListener('DOMContentLoaded', function() {
            // 导航和滚动相关代码
            const mobileMenuButton = document.getElementById('6d91ba5c-12c6-4e79-a4f0-383fc67cf816');
            const closeMenuButton = document.getElementById('close-menu');
            const mobileMenu = document.getElementById('mobile-menu');
            const backToTopButton = document.getElementById('back-to-top');
            
            mobileMenuButton.addEventListener('click', function() {
                mobileMenu.classList.toggle('hidden');
                mobileMenu.classList.toggle('flex');
            });
            
            closeMenuButton.addEventListener('click', function() {
                mobileMenu.classList.add('hidden');
                mobileMenu.classList.remove('flex');
            });
            
            document.querySelectorAll('#mobile-menu a').forEach(anchor => {
                anchor.addEventListener('click', function() {
                    mobileMenu.classList.add('hidden');
                    mobileMenu.classList.remove('flex');
                });
            });
            
            // 平滑滚动
            document.querySelectorAll('a[href^="#"]').forEach(anchor => {
                anchor.addEventListener('click', function(e) {
                    e.preventDefault();
                    const targetId = this.getAttribute('href');
                    const targetElement = document.querySelector(targetId);
                    
                    if (targetElement) {
                        window.scrollTo({
                            top: targetElement.offsetTop - 80,
                            behavior: 'smooth'
                        });
                    }
                });
            });
            
            // 回到顶部按钮
            window.addEventListener('scroll', function() {
                if (window.scrollY > 300) {
                    backToTopButton.style.opacity = '1';
                } else {
                    backToTopButton.style.opacity = '0';
                }
            });
            
            backToTopButton.addEventListener('click', function() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });
            });
            
            // 动画元素显示
            const animateElements = function() {
                const elements = document.querySelectorAll('.animated-element');
                
                elements.forEach(element => {
                    const position = element.getBoundingClientRect();
                    
                    // 元素进入视窗
                    if (position.top < window.innerHeight - 100) {
                        element.classList.add('visible');
                    }
                });
            };
            
            window.addEventListener('scroll', animateElements);
            animateElements(); // 初始检查
            
            // 设计模式分类图表
            const patternCategoriesChart = echarts.init(document.getElementById('patterns-categories-chart'));
            patternCategoriesChart.setOption({
                title: {
                    text: '设计模式分类',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'item',
                    formatter: '{a} <br/>{b}: {c} ({d}%)'
                },
                legend: {
                    orient: 'vertical',
                    left: 'left',
                    data: ['创建型模式', '结构型模式', '行为型模式']
                },
                color: ['#3b82f6', '#8b5cf6', '#10b981'],
                series: [
                    {
                        name: '设计模式',
                        type: 'pie',
                        radius: '65%',
                        center: ['50%', '60%'],
                        data: [
                            {value: 5, name: '创建型模式'},
                            {value: 7, name: '结构型模式'},
                            {value: 11, name: '行为型模式'}
                        ],
                        emphasis: {
                            itemStyle: {
                                shadowBlur: 10,
                                shadowOffsetX: 0,
                                shadowColor: 'rgba(0, 0, 0, 0.5)'
                            }
                        },
                        label: {
                            formatter: '{b}: {c} 种模式'
                        }
                    }
                ]
            });
            
            // 单例模式图表
            const singletonChart = echarts.init(document.getElementById('singleton-chart'));
            singletonChart.setOption({
                title: {
                    text: '单例模式 UML 图',
                    left: 'center'
                },
                tooltip: {
                    formatter: function(params) {
                        return params.data.name;
                    }
                },
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        edgeLabel: {
                            fontSize: 12
                        },
                        data: [
                            {
                                name: 'Singleton',
                                x: 300,
                                y: 150,
                                itemStyle: {
                                    color: '#3b82f6'
                                },
                                label: {
                                    formatter: 'Singleton\n-instance: Singleton\n+getInstance(): Singleton'
                                }
                            },
                            {
                                name: 'Client',
                                x: 150,
                                y: 150,
                                itemStyle: {
                                    color: '#8b5cf6'
                                }
                            }
                        ],
                        links: [
                            {
                                source: 'Client',
                                target: 'Singleton',
                                lineStyle: {
                                    width: 2,
                                    curveness: 0.2
                                }
                            }
                        ]
                    }
                ]
            });
            
            // 工厂模式图表
            const factoryChart = echarts.init(document.getElementById('factory-chart'));
            factoryChart.setOption({
                title: {
                    text: '工厂方法模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Creator',
                                x: 200,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Creator\n+factoryMethod()' }
                            },
                            {
                                name: 'Product',
                                x: 400,
                                y: 100,
                                itemStyle: { color: '#3b82f6' }
                            },
                            {
                                name: 'ConcreteCreator',
                                x: 200,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'ConcreteProduct',
                                x: 400,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            }
                        ],
                        links: [
                            {
                                source: 'ConcreteCreator',
                                target: 'Creator',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteProduct',
                                target: 'Product',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Creator',
                                target: 'Product',
                                lineStyle: { curveness: 0.2 }
                            },
                            {
                                source: 'ConcreteCreator',
                                target: 'ConcreteProduct',
                                lineStyle: { curveness: 0.2 }
                            }
                        ]
                    }
                ]
            });
            
            // 观察者模式图表
            const observerChart = echarts.init(document.getElementById('observer-chart'));
            observerChart.setOption({
                title: {
                    text: '观察者模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Subject',
                                x: 200,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Subject\n+attach()\n+detach()\n+notify()' }
                            },
                            {
                                name: 'Observer',
                                x: 400,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Observer\n+update()' }
                            },
                            {
                                name: 'ConcreteSubject',
                                x: 200,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'ConcreteObserver',
                                x: 400,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            }
                        ],
                        links: [
                            {
                                source: 'ConcreteSubject',
                                target: 'Subject',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteObserver',
                                target: 'Observer',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Subject',
                                target: 'Observer',
                                lineStyle: { curveness: 0.2 }
                            }
                        ]
                    }
                ]
            });
            
            // 策略模式图表
            const strategyChart = echarts.init(document.getElementById('strategy-chart'));
            strategyChart.setOption({
                title: {
                    text: '策略模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Context',
                                x: 150,
                                y: 100,
                                itemStyle: { color: '#3b82f6' }
                            },
                            {
                                name: 'Strategy',
                                x: 350,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Strategy\n+algorithm()' }
                            },
                            {
                                name: 'ConcreteStrategyA',
                                x: 300,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'ConcreteStrategyB',
                                x: 400,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            }
                        ],
                        links: [
                            {
                                source: 'Context',
                                target: 'Strategy',
                                label: { formatter: 'strategy' }
                            },
                            {
                                source: 'ConcreteStrategyA',
                                target: 'Strategy',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteStrategyB',
                                target: 'Strategy',
                                lineStyle: { type: 'dashed' }
                            }
                        ]
                    }
                ]
            });
            
            // 装饰器模式图表
            const decoratorChart = echarts.init(document.getElementById('decorator-chart'));
            decoratorChart.setOption({
                title: {
                    text: '装饰器模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Component',
                                x: 250,
                                y: 80,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Component\n+operation()' }
                            },
                            {
                                name: 'ConcreteComponent',
                                x: 150,
                                y: 180,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'Decorator',
                                x: 350,
                                y: 180,
                                itemStyle: { color: '#8b5cf6' }
                            },
                            {
                                name: 'ConcreteDecoratorA',
                                x: 300,
                                y: 280,
                                itemStyle: { color: '#f59e0b' }
                            },
                            {
                                name: 'ConcreteDecoratorB',
                                x: 400,
                                y: 280,
                                itemStyle: { color: '#f59e0b' }
                            }
                        ],
                        links: [
                            {
                                source: 'ConcreteComponent',
                                target: 'Component',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Decorator',
                                target: 'Component',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Decorator',
                                target: 'Component',
                                lineStyle: { curveness: 0.2 }
                            },
                            {
                                source: 'ConcreteDecoratorA',
                                target: 'Decorator',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteDecoratorB',
                                target: 'Decorator',
                                lineStyle: { type: 'dashed' }
                            }
                        ]
                    }
                ]
            });
            
            // 适配器模式图表
            const adapterChart = echarts.init(document.getElementById('adapter-chart'));
            adapterChart.setOption({
                title: {
                    text: '适配器模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Client',
                                x: 100,
                                y: 100,
                                itemStyle: { color: '#3b82f6' }
                            },
                            {
                                name: 'Target',
                                x: 250,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Target\n+request()' }
                            },
                            {
                                name: 'Adapter',
                                x: 250,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'Adaptee',
                                x: 400,
                                y: 200,
                                itemStyle: { color: '#8b5cf6' },
                                label: { formatter: 'Adaptee\n+specificRequest()' }
                            }
                        ],
                        links: [
                            {
                                source: 'Client',
                                target: 'Target'
                            },
                            {
                                source: 'Adapter',
                                target: 'Target',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Adapter',
                                target: 'Adaptee',
                            }
                        ]
                    }
                ]
            });
            
            // 命令模式图表
            const commandChart = echarts.init(document.getElementById('command-chart'));
            commandChart.setOption({
                title: {
                    text: '命令模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Invoker',
                                x: 100,
                                y: 100,
                                itemStyle: { color: '#3b82f6' }
                            },
                            {
                                name: 'Command',
                                x: 250,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Command\n+execute()' }
                            },
                            {
                                name: 'ConcreteCommand',
                                x: 250,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'Receiver',
                                x: 400,
                                y: 200,
                                itemStyle: { color: '#8b5cf6' },
                                label: { formatter: 'Receiver\n+action()' }
                            },
                            {
                                name: 'Client',
                                x: 150,
                                y: 200,
                                itemStyle: { color: '#f59e0b' }
                            }
                        ],
                        links: [
                            {
                                source: 'Invoker',
                                target: 'Command'
                            },
                            {
                                source: 'ConcreteCommand',
                                target: 'Command',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteCommand',
                                target: 'Receiver',
                            },
                            {
                                source: 'Client',
                                target: 'Receiver',
                                lineStyle: { curveness: 0.3 }
                            },
                            {
                                source: 'Client',
                                target: 'ConcreteCommand',
                                lineStyle: { curveness: -0.3 }
                            }
                        ]
                    }
                ]
            });
            
            // 代理模式图表
            const proxyChart = echarts.init(document.getElementById('proxy-chart'));
            proxyChart.setOption({
                title: {
                    text: '代理模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Client',
                                x: 100,
                                y: 150,
                                itemStyle: { color: '#3b82f6' }
                            },
                            {
                                name: 'Subject',
                                x: 250,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Subject\n+request()' }
                            },
                            {
                                name: 'RealSubject',
                                x: 350,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'Proxy',
                                x: 150,
                                y: 200,
                                itemStyle: { color: '#8b5cf6' }
                            }
                        ],
                        links: [
                            {
                                source: 'Client',
                                target: 'Subject'
                            },
                            {
                                source: 'RealSubject',
                                target: 'Subject',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Proxy',
                                target: 'Subject',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Proxy',
                                target: 'RealSubject',
                            }
                        ]
                    }
                ]
            });
            
            // 模板方法模式图表
            const templateChart = echarts.init(document.getElementById('template-chart'));
            templateChart.setOption({
                title: {
                    text: '模板方法模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'AbstractClass',
                                x: 250,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'AbstractClass\n+templateMethod()\n#primitiveOperation1()\n#primitiveOperation2()' }
                            },
                            {
                                name: 'ConcreteClassA',
                                x: 150,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'ConcreteClassB',
                                x: 350,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            }
                        ],
                        links: [
                            {
                                source: 'ConcreteClassA',
                                target: 'AbstractClass',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'ConcreteClassB',
                                target: 'AbstractClass',
                                lineStyle: { type: 'dashed' }
                            }
                        ]
                    }
                ]
            });
            
            // 组合模式图表
            const compositeChart = echarts.init(document.getElementById('composite-chart'));
            compositeChart.setOption({
                title: {
                    text: '组合模式 UML 图',
                    left: 'center'
                },
                tooltip: {},
                series: [
                    {
                        type: 'graph',
                        layout: 'none',
                        symbolSize: 60,
                        roam: false,
                        label: {
                            show: true
                        },
                        edgeSymbol: ['none', 'arrow'],
                        edgeSymbolSize: [0, 10],
                        data: [
                            {
                                name: 'Component',
                                x: 250,
                                y: 100,
                                itemStyle: { color: '#3b82f6' },
                                label: { formatter: 'Component\n+operation()' }
                            },
                            {
                                name: 'Leaf',
                                x: 150,
                                y: 200,
                                itemStyle: { color: '#10b981' }
                            },
                            {
                                name: 'Composite',
                                x: 350,
                                y: 200,
                                itemStyle: { color: '#10b981' },
                                label: { formatter: 'Composite\n+operation()\n+add()\n+remove()' }
                            },
                            {
                                name: 'Client',
                                x: 100,
                                y: 100,
                                itemStyle: { color: '#f59e0b' }
                            }
                        ],
                        links: [
                            {
                                source: 'Leaf',
                                target: 'Component',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Composite',
                                target: 'Component',
                                lineStyle: { type: 'dashed' }
                            },
                            {
                                source: 'Client',
                                target: 'Component'
                            },
                            {
                                source: 'Composite',
                                target: 'Component',
                                lineStyle: { curveness: 0.3 }
                            }
                        ]
                    }
                ]
            });
            
            // 设计模式选择指南图表
            const patternSelectionChart = echarts.init(document.getElementById('pattern-selection-chart'));
            patternSelectionChart.setOption({
                title: {
                    text: '设计模式选择指南',
                    left: 'center'
                },
                tooltip: {
                    trigger: 'axis',
                    axisPointer: {
                        type: 'shadow'
                    }
                },
                legend: {
                    data: ['复杂度', '灵活性', '可维护性'],
                    top: 30
                },
                grid: {
                    left: '3%',
                    right: '4%',
                    bottom: '3%',
                    containLabel: true
                },
                xAxis: {
                    type: 'category',
                    data: ['单例', '工厂方法', '观察者', '策略', '装饰器', '适配器', '命令', '代理', '模板方法', '组合']
                },
                yAxis: {
                    type: 'value',
                    max: 10
                },
                series: [
                    {
                        name: '复杂度',
                        type: 'bar',
                        stack: 'total',
                        emphasis: {
                            focus: 'series'
                        },
                        data: [2, 5, 7, 5, 7, 6, 8, 6, 4, 7]
                    },
                    {
                        name: '灵活性',
                        type: 'bar',
                        stack: 'total',
                        emphasis: {
                            focus: 'series'
                        },
                        data: [3, 7, 9, 8, 9, 7, 8, 6, 7, 8]
                    },
                    {
                        name: '可维护性',
                        type: 'bar',
                        stack: 'total',
                        emphasis: {
                            focus: 'series'
                        },
                        data: [7, 6, 5, 7, 6, 7, 5, 7, 8, 6]
                    }
                ]
            });
            
            // 监听窗口尺寸变化，重绘图表
            window.addEventListener('resize', function() {
                patternCategoriesChart.resize();
                singletonChart.resize();
                factoryChart.resize();
                observerChart.resize();
                strategyChart.resize();
                decoratorChart.resize();
                adapterChart.resize();
                commandChart.resize();
                proxyChart.resize();
                templateChart.resize();
                compositeChart.resize();
                patternSelectionChart.resize();
            });
        });
    </script>
</body>
</html>